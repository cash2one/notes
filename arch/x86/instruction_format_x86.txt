ModR/M
+---------------------------------------+
| Mod(7~6) | Reg/Opcode(5~3) | R/M(2~0) |
+---------------------------------------+
 
SIB (Scale-Index-Base)
+-------------------------------------+
| Scale(7~6) | Index(5~3) | Base(2~0) |
+-------------------------------------+

+-------------------------------------------------------------------------+
| Instruction Prefixes | Opcode | ModR/M | SIB | Displacement | Immediate |
+-------------------------------------------------------------------------+
Figure 2-1. Intel 64 and IA-32 Architectures Instruction Format

----> Instruction Prefixes
Up to four prefixes of 1 byte each (optional)

----> Opcode
A primary opcode can be 1, 2, or 3 bytes in length . An additional 3-bit opcode field 
is sometimes encoded in the ModR/M byte. Smaller fields can be defined within the pr-
imary opcode. Such fields define the direction of operation, size of displacements, -
register encoding, condition codes, or sign extension. Encoding fields used by an op-
code vary depending on the class of operation.

Two-byte opcode formats for general-purpose and SIMD instructions consist of:
• An escape opcode byte 0FH as the primary opcode and a second opcode byte, or
• A mandatory prefix (66H, F2H, or F3H), an escape opcode byte, and a second opcode b-
  yte
For example, CVTDQ2PD consists of the following sequence: F3 0F E6. The first byte is 
a mandatory prefix (it is not considered as a repeat prefix).

Three-byte opcode formats for general-purpose and SIMD instructions consist of:
• An escape opcode byte 0FH as the primary opcode, plus two additional opcode bytes, or
• A mandatory prefix (66H, F2H, or F3H), an escape opcode byte, plus two additional -
  opcode bytes 
For example, PHADDW for XMM registers consists of the following sequence:66 0F 38 01. 
The first byte is the mandatory prefix.
	
----> ModR/M  addressing-form specifier byte
Many instructions that refer to an operand in memory have an addressing-form specifi-
er byte (called the ModR/M byte) following the primary opcode. The ModR/M byte conta-
ins three fields of information:
• The mod field combines with the r/m field to form 32 possible values: eight regist-
  ers and 24 addressing modes.
• The reg/opcode field specifies either a register number or three more bits of opco-
  de information. The purpose of the reg/opcode field is specified in the primary op-
  code.
• The r/m field can specify a register as an operand or it can be combined with the -
  mod field to encode an addressing mode . Sometimes, certain combinations of the mod 
  field and the r/m field is used to express opcode information for some instructions.

Certain encodings of the ModR/M byte require a second addressing byte (the SIB byte). 
The base-plus-index and scale-plus-index forms of 32-bit addressing require the SIB -
byte. The SIB byte includes the following fields:
• The scale field specifies the scale factor.
• The index field specifies the register number of the index register.
• The base field specifies the register number of the base register.
See Section 2.1.5 for the encodings of the ModR/M and SIB bytes.
	
----> Displacement and Immediate Bytes
Some addressing forms include a displacement immediately following the ModR/M byte (-
or the SIB byte if one is present). If a displacement is required; it be 1, 2, or 4 -
bytes. If an instruction specifies an immediate operand, the operand always follows -
any displacement bytes. An immediate operand can be 1, 2 or 4 bytes.
	
	
	
imm是立即数的意思，而imm8就是指8个比特大小的立即数，
r：寄存器，如r16就代表ax、cx等，r32就代表eax、ebx等
m：内存地址，如[01]、[123]、[0FFFF]等
r/m：寄存器或内存
ib：代表OpCode后面跟着一个byte型数值
iw：代表OpCode后面跟着一个word型数值
id：代表OpCode后面跟着一个dword型数值
/digit：该指令存在ModR/M结构，且ModR/M结构的reg/opcode域为opcode：opcode的补充操作码
/r：代表此OpCode存在ModR/M结构，且ModR/M结构的reg/opcode域为reg，表示第二个操作码寄存器


83C0 01   add EAX,1
----> add 
Opcode    Instruction      Op/En  64-bit Mode  Compat/Leg Mode  Description
83 /0 ib  ADD r/m32, imm8  MI     Valid        Valid            Add sign-extended imm8 to r/m32

1 Opcode is 83
2 /0 表示存在ModR/M结构，查表 Table 2-2. 32-Bit Addressing Forms with the ModR/M Byte
  可知ModR/M结构为：
  /digit REG  Mod  R/M  
  0      000  11   000 = 000011000 = C0h (h表示C0是16进制)


01048E   ADD DWORD PTR DS:[ESI+ECX*4], EAX

Opcode    Instruction      Op/En  64-bit Mode  Compat/Leg Mode  Description
01 /r     ADD r/m32, r32   MR     Valid        Valid            Add r32 to r/m32.

1 Opcode is 01 
2 /r 表示存在ModR/M结构，查表 Table 2-2. 32-Bit Addressing Forms with the ModR/M Byte
  /r   REG  Mod  R/M  
  0    000  00   100 = 000000100 = 04h
3 根据“Effective Address”的“[--][--]”可知此OpCode还存在“SIB”结构,Table 2-3.
  SS  Index  Base
  10  001    110  = 10001110 = 8Eh

-------------------------------------------------------------------------------------
intel手册分为三册，手册1是给汇编程序员用的，主要指导你怎么写汇编程序；手册2是给编译器
设计者用的，主要指导你怎么给你的编译器写一个x86后端；手册3是给系统程序员用的，主要是
指导操作系统编写者如何利用CPU。


http://bbs.pediy.com/showthread.php?p=1291221  
http://bbs.pediy.com/showthread.php?t=113402   通过例子一步步深入

http://wenku.baidu.com/view/e532c6ef102de2bd9605880e.html



-------------------------------------------------------------------------------------|
http://www.luocong.com/learningopcode/doc/4._Prefixes_-_Part_II.htm                  |

----> Prefix 67  改变默认的地址大小。
8A 00       MOV AL, [EAX] # intel, AL = *EAX
现在把它的OpCode改成以67开头的：
67 8A 00    MOV AL, [BX+SI]
我们可以看到：地址由原来的32位的[EAX]变成了16位的[BX+SI]。

----> Repeat Prefixes (F2, F3)                                                       |
Repeat Prefixes作为一个串操作指令的前缀，它重复执行其后的串操作指令。每一次重复都先判|
断(E)CX是否为0，如为0就结束重复，否则(E)CX的值减1，然后再重复其后的串操作指令。所以当|
(E)CX的值为0时，就不再执行其后的操作指令。                                           |
                                                                                     |
----> Segment Override Prefixes (2E, 36, 3E, 26, 64, 65)                             |
Prefix	Explanation                                                                  |
2E	    CS segment override prefix                                                   |
36	    SS segment override prefix                                                   |
3E	    DS segment override prefix                                                   |
26	    ES segment override prefix                                                   |
64	    FS segment override prefix                                                   |
65	    GS segment override prefix                                                   |
再来看一个例子：                                                                     |
                                                                                     |
   8B 03    MOV EAX, [DWORD DS:EBX]                                                  |
65 8B 03    MOV EAX, [DWORD GS:EBX]                                                  |
65就是一个Segment override prefix，用来改变默认的段，从上表中我们可以看出：65代表的是|
段GS。注意！这里也是用默认的概念。怎么知道当前默认的是哪个段呢？以及为什么要用默认的 |
概念呢？在使用内存中的数据时，处理器必须首先知道它的段地址(Segment)和偏移量(Offset)，|
但是如果在每个地方都要显式地直接指出段地址，那么在OpCode格式中就必须增加一个新的域， |
这将会比现有的OpCode体系多占用大量的字节，而且处理器也必须多花费额外的时钟周期来进行 |
解码——无论在空间还是时间上，都不值得！因此，为了解决这个问题，一个方案诞生了：指令由 |
不同的定义被划分为不同的组，每个组各自有一个默认的段：                               |
CS: for EIP pointer                                                                  |
ES: 目的操作数是内存单元的串指令（movs, cmps等），在这里源操作数是储存在段DS里面。   |
SS: 堆栈操作（push, pop等）                                                          |
DS: 剩下的数据操作指令。                                                             |
有了这个规则，处理器识别当前应该用哪个段将会变得非常简单而直接：                     |
                                                                                     |
如果有“Segment override prefix”，那么就使用这个prefix所指定的段，否则就使用默认的段。|
看看：                                                                               |
   AC     LODS [BYTE DS:ESI]                                                         |
3E AC     LODS [BYTE DS:ESI]                                                         |
从上面的表中可以查出，3E是表示段DS，但是实际上在这里即使不直接指明3E，处理器也是会使 |
用DS的，因为DS是指令LODS的默认段。                                                   |
最后值得一提的是64，它表示的是段FS，也许读者会对FS不太熟悉，平时好像很少会用到。没关 |
系，我们来简单介绍一下：FS一般是由SEH（结构化异常处理）所使用,但是由于SEH不属于OpCode|
格式的范畴，所以我们在这里不必深究，知道有这个概念就行了。                           |



----> ModR/M

举个例子看看ModR/M到底是怎么来看的：
mov edi, ecx	8B F9 # 8B和2B就是Code
sub edi, ecx	2B F9 # F9是ModR/M

       Mod: 11
Reg/Opcode: 111
       R/M: 001
                                                                                     |	   
Mod总共分为00、01、10、11四种情况，每种情况又分别有8种情况。现在Mod是11，所以我们应该|
看Mod为11的那一栏(Table 2-2)。                                                       |
                                                                                     |
Reg/Opcode，反斜杠“/”代表或者的意思，也就是3个bit可能用来编码一个寄存器操作对象，但同|
时也可能联合前面的Opcode一起编码指令。当编码寄存器是，指的是8个通用寄存器中的一个。具|
体指的哪个，查表吧(Table 2-2)。                                                      |
                                                                                     |
R/M。这一栏要与Mod结合起来。我们来看Mod为11的那一栏——R/M为001对应的寄存器是ECX。     |

       Mod: 11  表示应该查看Mod为11的那一栏
Reg/Opcode: 111 表示的是寄存器EDI
       R/M: 001 表示的是ECX
	   
	   
	   
	   
http://download.csdn.net/download/yzyangzheng/2474580












