我们从应用的角度把寄存器分为4类：
通用寄存器
段寄存器
控制寄存器
其它寄存器



----> 通用寄存器

31                16                 0
 +--------+--------+--------+--------+
 |                %eax               |
 +--------+--------+--------+--------+

 +--------+--------+--------+--------+
 |       %ax       |   %ah  |   %al  |
 +--------+--------+--------+--------+

%eax  %ax[31~16] %ah[15~8] %al[7~0]
%ecx  %cx[31~16] %ch[15~8] %cl[7~0]
%edx  %dx[31~16] %dh[15~8] %dl[7~0]
%ebx  %bx[31~16] %bh[15~8] %bl[7~0]

%esi  %si[31~16]
%edi  %di[31~16]
%esp  %sp[31~16]     stack pointer
%ebp  %bp[31~16]     frame pointer


Due to its origins as a 16-bit architecture that expanded into a 32-bit one, Intel u-
ses the term “word” to refer to a 16-bit data type. Based on this , they refer to 32-
bit quantities as “double words.” They refer to 64-bit quantities as “quad words.”
“word”            16-bit
“double words”    32-bit
“quad words”      64-bit

As the table indicates, most assembly-code instructions generated by gcc have a sing-
le-character suffix denoting the size of the operand. For example, the data  movement 
instruction has three variants: movb (move byte), movw (move word), and movl (move d-
ouble word).
 
The suffix "l" is used for double words, since 32-bit
quantities are considered to be “long words,” a holdover from an era when 16-bit
word sizes were standard.Note that the assembly code uses the suffix "l" to denote
both a 4-byte integer as well as an 8-byte double-precision floating-point number.
This causes no ambiguity, since floating point involves an entirely different set of
instructions and registers.

----> 段寄存器
段寄存器是16位的(其它的寄存器是32位)。段寄存器CS、DS和SS一般用作段基址寄存器，向后兼
容16位的应用程序。
	
----> 控制寄存器
eip	
对于IA32来说，其中最重要的是"扩展指令指针"EIP(也称为"指令指针")，EIP中保存着下一条即
将执行的机器指令的地址。如果你想控制程序的执行流程，是否可以访问和改变保存在EIP中的
地址，将是整个问题的关键。

----> 其它寄存器
"其它"寄存器包括的是不属于前3个分类的寄存器，其中值得关注的是"扩展标志"(EFLAGS)寄存
器，它由不同的标志位组成，用于保存指令执行后的状态和控制指令执行流程的标志信息。	

----> Register Usage Conventions
procedure Q is called by P

caller-save registers: %eax, %edx, and %ecx
    P can overwrite these registers without destroying any data required by P. 
callee-save registers: %ebx, %esi, and %edi
    Q must save the values of  any of these registers on the stack before overwriting 
	them, and restore them before returning, because P (or some higher-level procedu-
	re) may need these values for its future computations.In addition, registers %ebp 
	and %esp must be maintained according to the conventions described here.

%eax  returning the value from any function that returns an integer or pointer.





