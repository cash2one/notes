我们从应用的角度把寄存器分为4类：
通用寄存器
段寄存器
控制寄存器
其它寄存器

----> 通用寄存器

31                16                 0
 +--------+--------+--------+--------+
 |                %eax               |
 +--------+--------+--------+--------+

 +--------+--------+--------+--------+
 |       %ax       |   %ah  |   %al  |
 +--------+--------+--------+--------+

%eax  %ax[31~16] %ah[15~8] %al[7~0]
%ecx  %cx[31~16] %ch[15~8] %cl[7~0]
%edx  %dx[31~16] %dh[15~8] %dl[7~0]
%ebx  %bx[31~16] %bh[15~8] %bl[7~0]

%esi  %si[31~16]
%edi  %di[31~16]
%esp  %sp[31~16]     stack pointer
%ebp  %bp[31~16]     frame pointer

%eax  returning the value from any function that returns an integer or pointer.
%eip  

Due to its origins as a 16-bit architecture that expanded into a 32-bit one, Intel u-
ses the term “word” to refer to a 16-bit data type. Based on this , they refer to 32-
bit quantities as “double words.” They refer to 64-bit quantities as “quad words.”
“word”            16-bit
“double words”    32-bit
“quad words”      64-bit

As the table indicates, most assembly-code instructions generated by gcc have a sing-
le-character suffix denoting the size of the operand. For example, the data  movement 
instruction has three variants: movb (move byte), movw (move word), and movl (move d-
ouble word).
 
The suffix "l" is used for double words, since 32-bit
quantities are considered to be “long words,” a holdover from an era when 16-bit
word sizes were standard.Note that the assembly code uses the suffix "l" to denote
both a 4-byte integer as well as an 8-byte double-precision floating-point number.
This causes no ambiguity, since floating point involves an entirely different set of
instructions and registers.

----> 段寄存器
http://blog.csdn.net/michael2012zhao/article/details/5554023

段寄存器是16位的(其它的寄存器是32位)。段寄存器CS、DS和SS一般用作段基址寄存器，向后兼
容16位的应用程序。
CS——代码段寄存器(Code Segment Register)，其值为代码段的段值；
DS——数据段寄存器(Data Segment Register)，其值为数据段的段值；
ES——附加段寄存器(Extra Segment Register)，其值为附加数据段的段值；
SS——堆栈段寄存器(Stack Segment Register)，其值为堆栈段的段值；
FS——附加段寄存器(Extra Segment Register)，其值为附加数据段的段值；
GS——附加段寄存器(Extra Segment Register)，其值为附加数据段的段值。
FS Windows就把fs用在处理程序异常方面。
GS windows把它们(fs gs)指向TEB,相当于一种接口

----> 控制寄存器
eip	
对于IA32来说，其中最重要的是"扩展指令指针"EIP(也称为"指令指针")，EIP中保存着下一条即
将执行的机器指令的地址。如果你想控制程序的执行流程，是否可以访问和改变保存在EIP中的
地址，将是整个问题的关键。

CR0~CR3
控制寄存器CR0~CR3用于控制和确定处理器的操作模式以及当前执行任务的特性。

CR3中含有页目录表物理内存基地址，因此该寄存器也被称为页目录基地址寄存器PDBR (Page Di-
rectory Base address Register)。
+-----------------------------------------------+
| Page-Directory Base (31~12) | Reserved (11~0) |  CR3
+-----------------------------------------------+

CR0中含有控制处理器操作模式和状态的系统控制标志
+----------------------------------------------------------------------------------+
|PG(31)|Reserved(30~19)|AW(18)|Reserved(17)|WP(16)|Reserved(15~6)|NE|ET|TS|EM|MP|PE|   CR0
+----------------------------------------------------------------------------------+
PG: Starting with the 80386, all 80x86 processors support paging; it is enabled by s-
    etting the PG flag. When PG = 0, linear addresses are interpreted as physical ad-
	dresses. 开启分页时，必须同时开启PE标志。
	
-------------------------------------------------------------------------------------|
----> 标志寄存器 EFLAGS                                                              |   
"扩展标志"(EFLAGS)寄存器，它由不同的标志位组成，用于保存指令执行后的状态和控制指令执 |
行流程的标志信息。通常只允许操作系统代码有权修改这些标志。                           |
+---------------------------------------------------------------------------------------+
|Reserved(31~18)|VW(17)|RF(16)|0(15)|NT(14)|IOPL(13~12)|OF|DF|IF|TF|SF|ZF|0|AF|0|PF|1|CF|  
+---------------------------------------------------------------------------------------+
---->----> indicate the results of arithmetic instructions
CF (bit 0) 
    Carry flag. Set if an arithmetic operation generates a carry or a borrow out of -
	the mostsignificant bit of the result; cleared otherwise . This flag indicates an 
	overflow condition for unsigned-integer arithmetic. It is also used in multiple -
	precision arithmetic.
PF (bit 2) 
    Parity flag. Set if the least-significant byte of the result contains an even nu-
	mber of 1 bits; cleared otherwise.
AF (bit 4) 
    Auxiliary Carry flag. Set if an arithmetic operation generates a carry or a borr-
	ow out of bit 3 of the result; cleared otherwise. This flag is used in binary co-
	ded decimal (BCD) arithmetic.
ZF (bit 6) 
    Zero flag. Set if the result is zero; cleared otherwise.
SF (bit 7) 
    Sign flag. Set equal to the most-significant bit of the result, which is the sig-
	n bit of a signed integer. (0 indicates a positive value and 1 indicates a negat-
	ive value.)
OF (bit 11) 
    Overflow flag. Set if the integer result is too large a positive number or too s-
	mall a negative number (excluding the sign-bit) to fit in the destination operand; 
	cleared otherwise. This flag indicates an overflow condition for signed-integer (
	two’s complement) arithmetic.

Of these status flags, only the CF flag can be modified directly, using the STC, CLC, 
and CMC instructions. Also the bit instructions (BT, BTS, BTR, and BTC) copy a speci-
fied bit into the CF flag.

For example, suppose we used one of the add instructions to perform the equivalent of 
the C assignment t=a+b, where variables a, b, and t are integers . Then the condition 
codes would be set according to the following C expressions:
CF: (unsigned) t < (unsigned)a               Unsigned overflow
ZF: (t == 0)                                 Zero
SF: (t < 0)                                  Negative
OF: (a < 0 == b < 0) && (t < 0 != a < 0)     Signed overflow

-------------------------------------------------------------------------------------
----> 其它寄存器
"其它"寄存器包括的是不属于前3个分类的寄存器，其中值得关注的是"扩展标志"(EFLAGS)寄存
器，它由不同的标志位组成，用于保存指令执行后的状态和控制指令执行流程的标志信息。	






----> Register Usage Conventions
procedure Q is called by P

caller-save registers: %eax, %edx, and %ecx
    P can overwrite these registers without destroying any data required by P. 
callee-save registers: %ebx, %esi, and %edi
    Q must save the values of  any of these registers on the stack before overwriting 
	them, and restore them before returning, because P (or some higher-level procedu-
	re) may need these values for its future computations.In addition, registers %ebp 
	and %esp must be maintained according to the conventions described here.







