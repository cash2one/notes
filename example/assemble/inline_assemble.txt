1 http://www.cnblogs.com/heiyue/archive/2011/10/27/2226570.html
2 http://blog.chinaunix.net/uid-7672958-id-2598961.html
3 Extensions to the C Language Family (gcc manual )
4 Using Inline Assembly with gcc
-------------------------------------------------------------------------------------
asm(“汇编语句”    
: 输出寄存器    
: 输入寄存器     
: 会被修改的寄存器 );    
其中，"汇编语句"是你写汇编指令的地方；"输出寄存器"表示当这段嵌入汇编执行完之后，哪些
寄存器用于存放输出数据。此地，这些寄存器会分别对应C语言表达式或一个内存地址；"输入寄
存器"表示在开始执行汇编代码时，这里指定的一些寄存器中应存放的输入值，它们也分别对应着
C变量或常数值。

下面我们用例子来说明嵌入汇编语句的使用方法。为了能看清楚我们将这段代码进行了重新编排
和编号。  
01  #define get_seg_byte(seg,addr) \ 
02  ({ \  
03  register char __res; \  
04  __asm__("push %%fs;  \ 
05           mov %%ax,%%fs;  \  
06           movb %%fs:%2,%%al;  \ 
07           pop %%fs"  \ 
08           :"=a" (__res)  \  
09           :"0" (seg),"m" (*(addr))); \ 
10  __res;}) 
   
这段10行代码定义了一个嵌入汇编语言宏函数。因为是宏语句，需要在一行上定义，因此这里使用
反斜杠'\'将这些语句连成一行。另外，为了让gcc编译产生的汇编语言程序中寄存器名称前有一个
百分号“%”，在嵌入汇编语句寄存器名称前就必须写上两个百分号“%%”。这条宏定义将被替换到宏
名称在程序中被引用的地方。

第1行定义了宏的名称，也即是宏函数名称get_seg_byte(seg,addr)。
第3行定义了一个寄存器变量 __res。
第4行上的__asm__表示嵌入汇编语句的开始。
第4行到第7行的4条AT&T格式的汇编语句。    
第8行即是输出寄存器，这句的含义是在这段代码运行结束后将eax所代表的寄存器的值放入__res
变量中，作为本函数的输出值，"=a"中的"a"称为加载代码， "="表示这是输出寄存器。
第9行表示在这段代码开始运行时将seg放到eax寄存器中，"0"表示使用与上面同个位置的输出相同
的寄存器。而(* (addr))表示一个内存偏移地址值。为了在上面汇编语句中使用该地址值，嵌入汇
编程序规定把输出和输入寄存器统一按顺序编号，顺序是从输出寄存器序列从左到右从上到下以
"%0"开始，分别记为%0、%1、…%9。因此，输出寄存器的编号是%0（这里只有一个输出寄存器），
输入寄存器前一部分("" (seg))的编号是%1，而后部分的编号是%2。上面第6行上的%2即代表
(*(addr))这个内存偏移量。   现在我们来研究4— 7行上的代码的作用。第一句将fs段寄存器的内
容入栈；第二句将eax中的段值赋给fs段寄存器；第三句是把fs:(*(addr))所指定的字节放入 al寄
存器中。当执行完汇编语句后，输出寄存器eax的值将被放入__res，作为该宏函数的返回值。很简
单，不是吗？    通过上面分析，我们知道，宏名称中的seg代表一指定的内存段值，而addr表示
一内存偏移地址量。到现在为止，我们应该很清楚这段程序的功能了吧！该宏函数的功能是从指定
段和偏移值的内存地址处取一个字节。 

在看下一个例子。 
01  asm("cld\n\t" 
02      "rep\n\t" 
03      "stol" 
04      : /* 没有输出寄存器 */ 
05      : "c"(count-1), "a"(fill_value), "D"(dest) 
06      : "%ecx", "%edi"); 

1-3行这三句是通常的汇编语句，用以清方向位，重复保存值。
第4行说明这段嵌入汇编程序没有用到输出寄存器。
第5行的含义是：将count-1的值加载到ecx寄存器中（加载代码是"c"），fill_value加载到eax中，
dest放到edi中。为什么要让gcc编译程序去做这样的寄存器值的加载，而不让我们自己做呢？因为
gcc在它进行寄存器分配时可以进行某些优化工作。例如fill_value值可能已经在eax中。如果是在
一个循环语句中的话，gcc就可能在整个循环操作中保留eax，这样就可以在每次循环中少用一个
movl语句。   
最后一行的作用是告诉gcc这些寄存器中的值已经改变了。很古怪吧？不过在gcc知道你拿这些寄存
器做些什么后，这确实能够对gcc的优化操作有所帮助。   

下面列表中，是一些你可能会用到的寄存器加载代码及其具体的含义。 
----------------------------------------------- 
a    使用寄存器eax    m    使用内存地址
b    使用寄存器ebx    o    使用内存地址并可以加偏移值
c    使用寄存器ecx    I    使用常数0-31
d    使用寄存器edx    J    使用常数0-63
S    使用esi          K    使用常数0-255
D    使用edi          L    使用常数0-65535
q    使用动态分配字节可寻址寄存器（eax，ebx，ecx或edx）    
M    使用常数0-3
r    使用任意动态分配的寄存器    
N    使用1字节常数（0-255）
g    使用通用有效的地址即可（eax，ebx，ecx，edx或内存变量）    
O    使用常数0-31
A    使用eax与edx联合（64位）    
=    输出操作数，输出值将替换前值
+    表示操作数可读可写    
&    早期汇编的操作数。表示在使用完操作数之前，内容会被修改

下面的例子不是让你自己指定哪个变量使用哪个寄存器，而是让gcc为你选择。 
01 asm("leal (%1, %1, 4), %0" 
02 : "=r"(y) 
03 : "0"(x)); 
第一句汇编语句leal (r1, r2,4), r3语句表示 r1+r2*4 &#61672; r3。这个例子可以非常快地将x
乘5。其中"%0","%1"是指gcc自动分配的寄存器。这里"%1"代表输入值x要放入的寄存器，"%0"表示
输出值寄存器。输出寄存器代码前一定要加等于号。如果输入寄存器的代码是0或为空时，则说明
使用与相应输出一样的寄存器。所以，如果gcc将r指定为eax的话，那么上面汇编语句的含义即为： 
"leal (eax,eax,4), eax" 
注意：在执行代码时，如果不希望汇编语句被gcc优化而挪动地方，就需要在asm符号后面添加
volatile关键词：   
asm volatile (……); 
或者更详细的说明为： 
__asm__ __volatile__ (……);   

下面在具一个较长的例子，如果能看得懂，那就说明嵌入汇编代码对你来说基本没问题了。这段代
码是从include/string.h文件中摘取的，是 strncmp()字符串比较函数的一种实现。需要注意的是
，其中每行中的"\n\t"是用于gcc预处理程序输出列表好看而设置的，含义与C语言中相同。

// 字符串1与字符串2的前count个字符进行比较。
// 参数：cs - 字符串1，ct - 字符串2，count - 比较的字符数。
// %0 - eax(__res)返回值，%1 - edi(cs)串1指针，%2 - esi(ct)串2指针，%3 - ecx(count)。
// 返回：如果串1 > 串2，则返回1；串1 = 串2，则返回0；串1 < 串2，则返回-1。
107 extern inline int strncmp(const char * cs,const char * ct,int count)
108 {
109 register int __res __asm__("ax");    // __res是寄存器变量(eax)。
110 __asm__("cld\n"                      // 清方向位。
111         "1:\tdecl %3\n\t"            // count--。
112         "js 2f\n\t"                  // 如果count<0，则向前跳转到标号2。
113         "lodsb\n\t"                  // 取串2的字符ds:[esi]al，并且esi++。
114         "scasb\n\t"                  // 比较al与串1的字符es:[edi]，并且edi++。
115         "jne 3f\n\t"                 // 如果不相等，则向前跳转到标号3。
116         "testb %%al,%%al\n\t"        // 该字符是NULL字符吗？
117         "jne 1b\n"                   // 不是，则向后跳转到标号1，继续比较。
118         "2:\txorl %%eax,%%eax\n\t"   // 是NULL字符，则eax清零（返回值）。
119         "jmp 4f\n"                   // 向前跳转到标号4，结束。
120         "3:\tmovl $1,%%eax\n\t"      // eax中置1。
121         "jl 4f\n\t"                  // 如果前面比较中串2字符<串2字符，则返回1，结束。
122         "negl %%eax\n"               // 否则eax = -eax，返回负值，结束。
123         "4:"
124         :"=a" (__res):"D" (cs),"S" (ct),"c" (count):"si","di","cx");
125 return __res;                        // 返回比较结果。
126 }















GCC内嵌汇编简介
在内嵌汇编中，可以将C语言表达式指定为汇编指令的操作数，而且不用去管如何将C语言表达式的值读入哪个寄存器，以及如何将计算结果写回C 变量，你只要告诉程序中C语言表达式与汇编指令操作数之间的对应关系即可， GCC会自动插入代码完成必要的操作。
1、简单的内嵌汇编
例：
__asm__ __volatile__("hlt"); “__asm__”表示后面的代码为内嵌汇编，“asm”是“__asm__” 的别名。“__volatile__”表示编译器不要优化代码，后面的指令 保留原样，“volatile”是它的别名。括号里面是汇编指令。
2、内嵌汇编举例
使用内嵌汇编，要先编写汇编指令模板，然后将C语言表达式与指令的操作数相关联，并告诉GCC对这些操作有哪些限制条件。例如在下面的汇编语句：
__asm__ __violate__ ("movl %1,%0" : "=r" (result) : "m" (input));
“movl %1,%0”是指令模板；“%0”和“%1”代表指令的操作数，称为占位符，内嵌汇编靠它们将C 语言表达式与指令操作数相对应。指令模板后面用小括号括起来的是C语言表达式，本例中只有两个：“result”和“input”，他们按照出现的顺序分 别与指令操作数“%0”，“%1”对应；注意对应顺序：第一个C 表达式对应“%0”；第二个表达式对应“%1”，依次类推，操作数至多有10 个，分别用“%0”,“%1”….“%9”表示。在每个操作数前面有一个用引号括起来的字符串，字符串的内容是对该操作数的限制或者说要求。 “result”前面的限制字符串是“=r”，其中“=”表示“result”是输出操作数，“r” 表示需要将“result”与某个通用寄存器相关联，先将操作数的值读入寄存器，然后在指令中使用相应寄存器，而不是“result”本身，当然指令执行 完后需要将寄存器中的值存入变量“result”，从表面上看好像是指令直接对“result”进行操作，实际上GCC做了隐式处理，这样我们可以少写一 些指令。“input”前面的“r”表示该表达式需要先放入某个寄存器，然后在指令中使用该寄存器参加运算。
C表达式或者变量与寄存器的关系由GCC自动处理，我们只需使用限制字符串指导GCC如何处理即可。限制字符必须与指令对操作数的要求相匹配，否则产生的 汇编代码将会有错，读者可以将上例中的两个“r”，都改为“m”(m表示操作数放在内存，而不是寄存器中)，编译后得到的结果是：
movl input, result
很明显这是一条非法指令，因此限制字符串必须与指令对操作数的要求匹配。例如指令movl允许寄存器到寄存器，立即数到寄存器等，但是不允许内存到内存的操作，因此两个操作数不能同时使用“m”作为限定字符。
GCC内嵌汇编之语法详解
内嵌汇编语法如下：
__asm__(汇编语句模板: 输出部分: 输入部分: 破坏描述部分)
共四个部分：汇编语句模板，输出部分，输入部分，破坏描述部分，各部分使用“:”格开，汇编语句模板必不可少，其他三部分可选，如果使用了后面的部分，而前面部分为空，也需要用“:”格开，相应部分内容为空。例如：
__asm__ __volatile__("cli": : :"memory")
1、汇编语句模板
汇编语句模板由汇编语句序列组成，语句之间使用“;”、“\n”或“\n\t”分开。指令中的操作数可以使用占位符引用C语言变量，操作数占位符最多10 个，名称如下：%0，%1，…，%9。指令中使用占位符表示的操作数，总被视为long型（4个字节），但对其施加的操作根据指令可以是字或者字节，当把 操作数当作字或者字节使用时，默认为低字或者低字节。对字节操作可以显式的指明是低字节还是次字节。方法是在%和序号之间插入一个字母，“b”代表低字 节，“h”代表高字节，例如：%h1。
2、输出部分
输出部分描述输出操作数，不同的操作数描述符之间用逗号格开，每个操作数描述符由限定字符串和C 语言变量组成。每个输出操作数的限定字符串必须包含“=”表示他是一个输出操作数。
例：
__asm__ __volatile__("pushfl ; popl %0 ; cli":"=g" (x) )
描述符字符串表示对该变量的限制条件，这样GCC 就可以根据这些条件决定如何分配寄存器，如何产生必要的代码处理指令操作数与C表达式或C变量之间的联系。
3、输入部分
输入部分描述输入操作数，不同的操作数描述符之间使用逗号格开，每个操作数描述符由限定字符串和C语言表达式或者C语言变量组成。
例1 ：
__asm__ __volatile__ ("lidt %0" : : "m" (real_mode_idt));
例二（bitops.h）：
Static __inline__ void __set_bit(int nr, volatile void * addr)
{
__asm__(
"btsl %1,%0"
:"=m" (ADDR)
:"Ir" (nr));
}
后例功能是将(*addr)的第nr位设为1。第一个占位符%0与C 语言变量ADDR对应，第二个占位符%1与C语言变量nr对应。因此上面的汇编语句代码与下面的伪代码等价：btsl nr, ADDR，该指令的两个操作数不能全是内存变量，因此将nr的限定字符串指定为“Ir”，将nr 与立即数或者寄存器相关联，这样两个操作数中只有ADDR为内存变量。
4、限制字符
4.1、限制字符列表
限制字符有很多种，有些是与特定体系结构相关，此处仅列出常用的限定字符和i386中可能用到的一些常用的限定符。它们的作用是指示编译器如何处理其后的C语言变量与指令操作数之间的关系。
分类 限定符 描述
通用寄存器 “a” 将输入变量放入eax
这里有一个问题：假设eax已经被使用，那怎么办？
其实很简单：因为GCC 知道eax 已经被使用，它在这段汇编代码
的起始处插入一条语句pushl %eax，将eax 内容保存到堆栈，然
后在这段代码结束处再增加一条语句popl %eax，恢复eax的内容
“b” 将输入变量放入ebx
“c” 将输入变量放入ecx
“d” 将输入变量放入edx
“s” 将输入变量放入esi
“d” 将输入变量放入edi
“q” 将输入变量放入eax，ebx，ecx，edx中的一个
“r” 将输入变量放入通用寄存器，也就是eax，ebx，ecx，
edx，esi，edi中的一个
“A” 把eax和edx合成一个64 位的寄存器(use long longs)
内存 “m” 内存变量
“o” 操作数为内存变量，但是其寻址方式是偏移量类型，
也即是基址寻址，或者是基址加变址寻址
“V” 操作数为内存变量，但寻址方式不是偏移量类型
“ ” 操作数为内存变量，但寻址方式为自动增量
“p” 操作数是一个合法的内存地址（指针）
寄存器或内存 “g” 将输入变量放入eax，ebx，ecx，edx中的一个
或者作为内存变量
“X” 操作数可以是任何类型
立即数
“I” 0-31之间的立即数（用于32位移位指令）
“J” 0-63之间的立即数（用于64位移位指令）
“N” 0-255之间的立即数（用于out指令）
“i” 立即数
“n” 立即数，有些系统不支持除字以外的立即数，
这些系统应该使用“n”而不是“i”
匹配 “ 0 ”， 表示用它限制的操作数与某个指定的操作数匹配，
“1” ... 也即该操作数就是指定的那个操作数，例如“0”
“9” 去描述“％1”操作数，那么“%1”引用的其实就
是“%0”操作数，注意作为限定符字母的0－9 与
指令中的“％0”－“％9”的区别，前者描述操作数，
后者代表操作数。
& 该输出操作数不能使用过和输入操作数相同的寄存器
操作数类型 “=” 操作数在指令中是只写的（输出操作数）
“+” 操作数在指令中是读写类型的（输入输出操作数）
浮点数 “f” 浮点寄存器
“t” 第一个浮点寄存器
“u” 第二个浮点寄存器
“G” 标准的80387浮点常数
% 该操作数可以和下一个操作数交换位置
例如addl的两个操作数可以交换顺序
（当然两个操作数都不能是立即数）
# 部分注释，从该字符到其后的逗号之间所有字母被忽略
* 表示如果选用寄存器，则其后的字母被忽略
5、破坏描述部分
破坏描述符用于通知编译器我们使用了哪些寄存器或内存，由逗号格开的字符串组成，每个字符串描述一种情况，一般是寄存器名；除寄存器外还有“memory”。例如：“%eax”，“%ebx”，“memory”等。
AT&T与INTEL的汇编语言语法的区别
1、大小写
INTEL格式的指令使用大写字母，而AT&T格式的使用小写字母。
例：
INTEL AT&T
MOV EAX,EBX movl %ebx,%eax
2、操作数赋值方向
在INTEL语法中，第一个表示目的操作数，第二个表示源操作数，赋值方向从右向左。
AT&T语法第一个为源操作数，第二个为目的操作数，方向从左到右，合乎自然。
例：
INTEL AT&T
MOV EAX,EBX movl %ebx,%eax
3、前缀
在INTEL 语法中寄存器和立即数不需要前缀；AT&T 中寄存器需要加前缀“%”；立即数
需要加前缀“$”。
例：
INTEL AT&T
MOV EAX,1 movl $1,%eax
符号常数直接引用，不需要加前缀，如：movl value , %ebx，value为一常数；在符
号前加前缀$表示引用符号地址, 如movl $value, %ebx，是将value的地址放到ebx中。
总线锁定前缀“lock”：总线锁定操作。“lock”前缀在Linux 核心代码中使用很多，特
别是SMP代码中。当总线锁定后其它CPU不能存取锁定地址处的内存单元。
远程跳转指令和子过程调用指令的操作码使用前缀“l“，分别为ljmp，lcall，与之
相应的返回指令伪lret。
例：
INTEL AT&T
CALL FAR SECTION:OFFSET lcall $secion:$offset
JMP FAR SECTION:OFFSET ljmp $secion:$offset
RET FAR SATCK_ADJUST lret $stack_adjust
4 、间接寻址语法
INTEL 中基地址使用“[”、“] ”，而在AT&T 中使用“(”、“) ”；另外处理复杂操作数的
语法也不同， INTEL 为Segreg:[base+index*scale+disp] ， 而在AT&T 中为
%segreg:disp(base,index,sale)，其中segreg，index，scale，disp都是可选的，在指定
index而没有显式指定Scale的情况下使用默认值1。Scale和disp不需要加前缀“&”。
INTEL AT&T
Instr instr
foo,segreg:[base+index*scale+disp] %segreg:disp(base,index,scale),foo
5、后缀
AT&T 语法中大部分指令操作码的最后一个字母表示操作数大小，“b”表示byte（一个
字节）；“w ”表示word（2 个字节）；“l ”表示long（4 个字节）。INTEL 中处理内存操作数
时也有类似的语法如：BYTE PTR、WORD PTR、DWORD PTR。
例：
INTEL AT&T
mov al, bl movb %bl,%al
mov ax,bx movw %bx,%ax
mov eax, dword ptr [ebx] movl (%ebx), %eax
在AT&T 汇编指令中，操作数扩展指令有两个后缀，一个指定源操作数的字长，另一个
指定目标操作数的字长。AT&T 的符号扩展指令的为“movs”，零扩展指令为“movz”（相应
的Intel指令为“movsx”和“movzx”）。因此，“movsbl %al,%edx”表示对寄存器al 中的
字节数据进行字节到长字的符号扩展，计算结果存放在寄存器edx中。下面是一些允许的操
作数扩展后缀：
bl: 字节->长字
bw: 字节->字
wl: 字->长字
跳转指令标号后的后缀表示跳转方向，“f”表示向前（forward），“b”表示向后（back）。
例：
jmp 1f
1: jmp 1f
1:
6、指令
INTEL 汇编与AT&T 汇编指令基本相同，差别仅在语法上。关于每条指令的语法可以参考I386 Manual。
http://www.icwin.net/ShowArtitle.ASP?art_id=8581&cat_id=16
__asm__ __volatile__ GCC的内嵌汇编语法 AT&T汇编语言语法
AT&T ASM Syntax
1 Overview
开发一个OS，尽管绝大部分代码只需要用C/C++等高级语言就可以了，但至少和硬件相关部分的代码需要使用汇编语言，另外，由于启动部分的代码有 大小限制，使用精练的汇编可以缩小目标代码的Size。另外，对于某些需要被经常调用的代码，使用汇编来写可以提高性能。所以我们必须了解汇编语言，即使 你有可能并不喜欢它。
如果你是计算机专业的话，在大学里你应该学习过Intel格式的8086/80386汇编，这里就不再讨论。如果我们选择的OS开发工具是GCC以及GAS的话，就必须了解AT&T汇编语言语法，因为GCC/GAS只支持这种汇编语法。
本书不会去讨论8086/80386的汇编编程，这类的书籍很多，你可以参考它们。这里只会讨论AT&T的汇编语法，以及GCC的内嵌汇编语法。
--------------------------------------------------------------------------------
0.3.2 Syntax
1.寄存器引用
引用寄存器要在寄存器号前加百分号%,如“movl %eax, %ebx”。
80386有如下寄存器：
8个32-bit寄存器 %eax，%ebx，%ecx，%edx，%edi，%esi，%ebp，%esp；
8个16-bit寄存器，它们事实上是上面8个32-bit寄存器的低16位：%ax，%bx，%cx，%dx，%di，%si，%bp，%sp；
8个8-bit寄存器：%ah，%al，%bh，%bl，%ch，%cl，%dh，%dl。它们事实上是寄存器%ax，%bx，%cx，%dx的高8位和低8位；
6个段寄存器：%cs(code)，%ds(data)，%ss(stack), %es，%fs，%gs；
3个控制寄存器：%cr0，%cr2，%cr3；
6个debug寄存器：%db0，%db1，%db2，%db3，%db6，%db7；
2个测试寄存器：%tr6，%tr7；
8个浮点寄存器栈：%st(0)，%st(1)，%st(2)，%st(3)，%st(4)，%st(5)，%st(6)，%st(7)。
2. 操作数顺序
操作数排列是从源（左）到目的（右），如“movl %eax(源）, %ebx(目的）”
3. 立即数
使用立即数，要在数前面加符号$, 如“movl $0x04, %ebx”
或者：
para = 0x04
movl $para, %ebx
指令执行的结果是将立即数04h装入寄存器ebx。
4. 符号常数
符号常数直接引用 如
value: .long 0x12a3f2de
movl value , %ebx
指令执行的结果是将常数0x12a3f2de装入寄存器ebx。
引用符号地址在符号前加符号$, 如“movl $value, % ebx”则是将符号value的地址装入寄存器ebx。
5. 操作数的长度
操作数的长度用加在指令后的符号表示b(byte, 8-bit), w(word, 16-bits), l(long, 32-bits)，如“movb %al, %bl”，“movw %ax, %bx”，“movl %eax, %ebx ”。
如果没有指定操作数长度的话，编译器将按照目标操作数的长度来设置。比如指令“mov %ax, %bx”，由于目标操作数bx的长度为word，那么编译器将把此指令等同于“movw %ax, %bx”。同样道理，指令“mov $4, %ebx”等同于指令“movl $4, %ebx”，“push %al”等同于“pushb %al”。对于没有指定操作数长度，但编译器又无法猜测的指令，编译器将会报错，比如指令“push $4”。
6. 符号扩展和零扩展指令
绝大多数面向80386的AT&T汇编指令与Intel格式的汇编指令都是相同的，符号扩展指令和零扩展指令则是仅有的不同格式指令。
符号扩展指令和零扩展指令需要指定源操作数长度和目的操作数长度，即使在某些指令中这些操作数是隐含的。
在AT& T语法中，符号扩展和零扩展指令的格式为，基本部分"movs"和"movz"（对应Intel语法的movsx和movzx），后面跟上源操作数长度和 目的操作数长度。movsbl意味着movs （from）byte （to）long；movbw意味着movs （from）byte （to）word；movswl意味着movs （from）word （to）long。对于movz指令也一样。比如指令“movsbl %al, %edx”意味着将al寄存器的内容进行符号扩展后放置到edx寄存器中。
其它的Intel格式的符号扩展指令还有：
cbw -- sign-extend byte in %al to word in %ax；
cwde -- sign-extend word in %ax to long in %eax；
cwd -- sign-extend word in %ax to long in %dx:%ax；
cdq -- sign-extend dword in %eax to quad in %edx:%eax；
对应的AT&T语法的指令为cbtw，cwtl，cwtd，cltd。
7. 调用和跳转指令
段内调用和跳转指令为"call"，"ret"和"jmp"，段间调用和跳转指令为"lcall"，"lret"和"ljmp"。
段间调用和跳转指令的格式为“lcall/ljmp $SECTION, $OFFSET”，而段间返回指令则为“lret $STACK-ADJUST”。
8. 前缀
操作码前缀被用在下列的情况：
字符串重复操作指令(rep,repne)；
指定被操作的段(cs,ds,ss,es,fs,gs)；
进行总线加锁(lock)；
指定地址和操作的大小(data16,addr16)；
在AT&T汇编语法中，操作码前缀通常被单独放在一行，后面不跟任何操作数。例如，对于重复scas指令，其写法为：
repne
scas
上述操作码前缀的意义和用法如下：
指定被操作的段前缀为cs,ds,ss,es,fs,和gs。在AT&T语法中，只需要按照section:memory-operand的格式就指定了相应的段前缀。比如：lcall %cs:realmode_swtch
操作数／地址大小前缀是“data16”和"addr16"，它们被用来在32-bit操作数／地址代码中指定16-bit的操作数／地址。
总线加锁前缀“lock”，它是为了在多处理器环境中，保证在当前指令执行期间禁止一切中断。这个前缀仅仅对ADD, ADC, AND, BTC, BTR, BTS, CMPXCHG,DEC, INC, NEG, NOT, OR, SBB, SUB, XOR, XADD,XCHG指令有效，如果将Lock前缀用在其它指令之前，将会引起异常。
字符串重复操作前缀"rep","repe","repne"用来让字符串操作重复“%ecx”次。
9. 内存引用
Intel语法的间接内存引用的格式为：
section:[base+index*scale+displacement]
而在AT&T语法中对应的形式为：
section:displacement(base,index,scale)
其中，base和index是任意的32-bit base和index寄存器。scale可以取值1，2，4，8。如果不指定scale值，则默认值为1。section可以指定任意的段寄存器作为段前 缀，默认的段寄存器在不同的情况下不一样。如果你在指令中指定了默认的段前缀，则编译器在目标代码中不会产生此段前缀代码。
下面是一些例子：
-4(%ebp)：base=%ebp，displacement=-4，section没有指定，由于base＝%ebp，所以默认的section=%ss，index,scale没有指定，则index为0。
foo(,%eax,4)：index=%eax，scale=4，displacement=foo。其它域没有指定。这里默认的section=%ds。
foo(,1)：这个表达式引用的是指针foo指向的地址所存放的值。注意这个表达式中没有base和index，并且只有一个逗号，这是一种异常语法，但却合法。
%gs:foo：这个表达式引用的是放置于%gs段里变量foo的值。
如果call和jump操作在操作数前指定前缀“*”，则表示是一个绝对地址调用/跳转，也就是说jmp/call指令指定的是一个绝对地址。如果没有指定"*"，则操作数是一个相对地址。
任何指令如果其操作数是一个内存操作，则指令必须指定它的操作尺寸(byte,word,long），也就是说必须带有指令后缀(b,w,l)。
.3 GCC Inline ASM
GCC 支持在C/C++代码中嵌入汇编代码，这些汇编代码被称作GCC Inline ASM——GCC内联汇编。这是一个非常有用的功能，有利于我们将一些C/C++语法无法表达的指令直接潜入C/C++代码中，另外也允许我们直接写 C/C++代码中使用汇编编写简洁高效的代码。
1.基本内联汇编
GCC中基本的内联汇编非常易懂，我们先来看两个简单的例子：
__asm__("movl %esp,%eax"); // 看起来很熟悉吧！
或者是
__asm__("
movl $1,%eax // SYS_exit
xor %ebx,%ebx
int $0x80
");
或
__asm__(
"movl $1,%eax\r\t" \
"xor %ebx,%ebx\r\t" \
"int $0x80" \
);
基本内联汇编的格式是
__asm__ __volatile__("Instruction List");
1、__asm__
__asm__是GCC关键字asm的宏定义：
#define __asm__ asm
__asm__或asm用来声明一个内联汇编表达式，所以任何一个内联汇编表达式都是以它开头的，是必不可少的。
2、Instruction List
Instruction List是汇编指令序列。它可以是空的，比如：__asm__ __volatile__(""); 或__asm__ ("");都是完全合法的内联汇编表达式，只不过这两条语句没有什么意义。但并非所有Instruction List为空的内联汇编表达式都是没有意义的，比如：__asm__ ("":::"memory"); 就非常有意义，它向GCC声明：“我对内存作了改动”，GCC在编译的时候，会将此因素考虑进去。
我们看一看下面这个例子：
$ cat example1.c
int main(int __argc, char* __argv[])
{
int* __p = (int*)__argc;
(*__p) = 9999;
//__asm__("":::"memory");
if((*__p) == 9999)
return 5;
return (*__p);
}
在这段代码中，那条内联汇编是被注释掉的。在这条内联汇编之前，内存指针__p所指向的内存被赋值为9999，随即在内联汇编之后，一条if语句判 断__p 所指向的内存与9999是否相等。很明显，它们是相等的。GCC在优化编译的时候能够很聪明的发现这一点。我们使用下面的命令行对其进行编译：
$ gcc -O -S example1.c
选项-O表示优化编译，我们还可以指定优化等级，比如-O2表示优化等级为2；选项-S表示将C/C++源文件编译为汇编文件，文件名和C/C++文件一样，只不过扩展名由.c变为.s。
我们来查看一下被放在example1.s中的编译结果，我们这里仅仅列出了使用gcc 2.96在redhat 7.3上编译后的相关函数部分汇编代码。为了保持清晰性，无关的其它代码未被列出。
$ cat example1.s
main:
pushl %ebp
movl %esp, %ebp
movl 8(%ebp), %eax # int* __p = (int*)__argc
movl $9999, (%eax) # (*__p) = 9999
movl $5, %eax # return 5
popl %ebp
ret
参照一下C源码和编译出的汇编代码，我们会发现汇编代码中，没有if语句相关的代码，而是在赋值语句(*__p)=9999后直接return 5；这是因为GCC认为在(*__p)被赋值之后，在if语句之前没有任何改变(*__p)内容的操作，所以那条if语句的判断条件(*__p) == 9999肯定是为true的，所以GCC就不再生成相关代码，而是直接根据为true的条件生成return 5的汇编代码（GCC使用eax作为保存返回值的寄存器）。
我们现在将example1.c中内联汇编的注释去掉，重新编译，然后看一下相关的编译结果。
$ gcc -O -S example1.c
$ cat example1.s
main:
pushl %ebp
movl %esp, %ebp
movl 8(%ebp), %eax # int* __p = (int*)__argc
movl $9999, (%eax) # (*__p) = 9999
#APP
# __asm__("":::"memory")
#NO_APP
cmpl $9999, (%eax) # (*__p) == 9999 ?
jne .L3 # false
movl $5, %eax # true, return 5
jmp .L2
.p2align 2
.L3:
movl (%eax), %eax
.L2:
popl %ebp
ret
由于内联汇编语句__asm__("":::"memory")向GCC声明，在此内联汇编语句出现的位置内存内容可能了改变，所以GCC在编译时就不能像刚才那样处理。这次，GCC老老实实的将if语句生成了汇编代码。
可能有人会质疑：为什么要使用__asm__("":::"memory")向GCC声明内存发生了变化？明明“Instruction List”是空的，没有任何对内存的操作，这样做只会增加GCC生成汇编代码的数量。
确实，那条内联汇编语句没有对内存作任何操作，事实上它确实什么都没有做。但影响内存内容的不仅仅是你当前正在运行的程序。比如，如果你现在正在操 作的内存是一块内存映射，映射的内容是外围I/O设备寄存器。那么操作这块内存的就不仅仅是当前的程序，I/O设备也会去操作这块内存。既然两者都会去操 作同一块内存，那么任何一方在任何时候都不能对这块内存的内容想当然。所以当你使用高级语言C/C++写这类程序的时候，你必须让编译器也能够明白这一 点，毕竟高级语言最终要被编译为汇编代码。
你可能已经注意到了，这次输出的汇编结果中，有两个符号：#APP和#NO_APP，GCC将内联汇编语句中"Instruction List"所列出的指令放在#APP和#NO_APP之间，由于__asm__("":::"memory")中“Instruction List”为空，所以#APP和#NO_APP中间也没有任何内容。但我们以后的例子会更加清楚的表现这一点。
关于为什么内联汇编__asm__("":::"memory")是一条声明内存改变的语句，我们后面会详细讨论。
刚才我们花了大量的内容来讨论"Instruction List"为空是的情况，但在实际的编程中，"Instruction List"绝大多数情况下都不是空的。它可以有1条或任意多条汇编指令。
当在"Instruction List"中有多条指令的时候，你可以在一对引号中列出全部指令，也可以将一条或几条指令放在一对引号中，所有指令放在多对引号中。如果是前者，你可以将 每一条指令放在一行，如果要将多条指令放在一行，则必须用分号（；）或换行符（\n，大多数情况下\n后还要跟一个\t，其中\n是为了换行，\t是为了 空出一个tab宽度的空格）将它们分开。比如：
__asm__("movl %eax, %ebx
sti
popl %edi
subl %ecx, %ebx");
__asm__("movl %eax, %ebx; sti
popl %edi; subl %ecx, %ebx");
__asm__("movl %eax, %ebx; sti\n\t popl %edi
subl %ecx, %ebx");
都是合法的写法。如果你将指令放在多对引号中，则除了最后一对引号之外，前面的所有引号里的最后一条指令之后都要有一个分号(；)或(\n)或(\n\t)。比如：
__asm__("movl %eax, %ebx
sti\n"
"popl %edi;"
"subl %ecx, %ebx");
__asm__("movl %eax, %ebx; sti\n\t"
"popl %edi; subl %ecx, %ebx");
__asm__("movl %eax, %ebx; sti\n\t popl %edi\n"
"subl %ecx, %ebx");
__asm__("movl %eax, %ebx; sti\n\t popl %edi;" "subl %ecx, %ebx");
都是合法的。
上述原则可以归结为：
任意两个指令间要么被分号(；)分开，要么被放在两行；
放在两行的方法既可以从通过\n的方法来实现，也可以真正的放在两行；
可以使用1对或多对引号，每1对引号里可以放任一多条指令，所有的指令都要被放到引号中。
在基本内联汇编中，“Instruction List”的书写的格式和你直接在汇编文件中写非内联汇编没有什么不同，你可以在其中定义Label，定义对齐(.align n )，定义段(.section name )。例如：
__asm__(".align 2\n\t"
"movl %eax, %ebx\n\t"
"test %ebx, %ecx\n\t"
"jne error\n\t"
"sti\n\t"
"error: popl %edi\n\t"
"subl %ecx, %ebx");
上面例子的格式是Linux内联代码常用的格式，非常整齐。也建议大家都使用这种格式来写内联汇编代码。
3、__volatile__
__volatile__是GCC关键字volatile的宏定义：
#define __volatile__ volatile
__volatile__ 或volatile是可选的，你可以用它也可以不用它。如果你用了它，则是向GCC声明“不要动我所写的Instruction List，我需要原封不动的保留每一条指令”，否则当你使用了优化选项(-O)进行编译时，GCC将会根据自己的判断决定是否将这个内联汇编表达式中的指 令优化掉。
那么GCC判断的原则是什么？我不知道（如果有哪位朋友清楚的话，请告诉我）。我试验了一下，发现一条内联汇编语句如果是基本内联汇编的话（即只有 “Instruction List”，没有Input/Output/Clobber的内联汇编，我们后面将会讨论这一点），无论你是否使用__volatile__来修饰， GCC 2.96在优化编译时，都会原封不动的保留内联汇编中的“Instruction List”。但或许我的试验的例子并不充分，所以这一点并不能够得到保证。
为了保险起见，如果你不想让GCC的优化影响你的内联汇编代码，你最好在前面都加上__volatile__，而不要依赖于编译器的原则，因为即使你非常了解当前编译器的优化原则，你也无法保证这种原则将来不会发生变化。而__volatile__的含义却是恒定的。
2、带有C/C++表达式的内联汇编
GCC允许你通过C/C++表达式指定内联汇编中"Instrcuction List"中指令的输入和输出，你甚至可以不关心到底使用哪个寄存器被使用，完全靠GCC来安排和指定。这一点可以让程序员避免去考虑有限的寄存器的使用，也可以提高目标代码的效率。
我们先来看几个例子：
__asm__ (" " : : : "memory" ); // 前面提到的
__asm__ ("mov %%eax, %%ebx" : "=b"(rv) : "a"(foo) : "eax", "ebx");
__asm__ __volatile__("lidt %0": "=m" (idt_descr));
__asm__("subl %2,%0\n\t"
"sbbl %3,%1"
: "=a" (endlow), "=d" (endhigh)
: "g" (startlow), "g" (starthigh), "0" (endlow), "1" (endhigh));
怎么样，有点印象了吧，是不是也有点晕？没关系，下面讨论完之后你就不会再晕了。（当然，也有可能更晕^_^）。讨论开始——
带有C/C++表达式的内联汇编格式为：
__asm__　__volatile__("Instruction List" : Output : Input : Clobber/Modify);
从中我们可以看出它和基本内联汇编的不同之处在于：它多了3个部分(Input，Output，Clobber/Modify)。在括号中的4个部分通过冒号(:)分开。
这4个部分都不是必须的，任何一个部分都可以为空，其规则为：
如果Clobber/Modify为空，则其前面的冒号(:)必须省略。比如__asm__("mov %%eax, %%ebx" : "=b"(foo) : "a"(inp) : )就是非法的写法；而__asm__("mov %%eax, %%ebx" : "=b"(foo) : "a"(inp) )则是正确的。
如果Instruction List为空，则Input，Output，Clobber/Modify可以不为空，也可以为空。比如__asm__ ( " " : : : "memory" );和__asm__(" " : : );都是合法的写法。
如果Output，Input，Clobber/Modify都为空，Output，Input之前的冒号(:)既可以省略，也可以不省略。如果都省略， 则此汇编退化为一个基本内联汇编，否则，仍然是一个带有C/C++表达式的内联汇编，此时"Instruction List"中的寄存器写法要遵守相关规定，比如寄存器前必须使用两个百分号(%%)，而不是像基本汇编格式一样在寄存器前只使用一个百分号(%)。比如 __asm__( " mov %%eax, %%ebx" : : )；__asm__( " mov %%eax, %%ebx" : )和__asm__( " mov %eax, %ebx" )都是正确的写法，而__asm__( " mov %eax, %ebx" : : )；__asm__( " mov %eax, %ebx" : )和__asm__( " mov %%eax, %%ebx" )都是错误的写法。
如果Input，Clobber/Modify为空，但Output不为空，Input前的冒号(:)既可以省略，也可以不省略。比如 __asm__( " mov %%eax, %%ebx" : "=b"(foo) : )；__asm__( " mov %%eax, %%ebx" : "=b"(foo) )都是正确的。
如果后面的部分不为空，而前面的部分为空，则前面的冒号(:)都必须保留，否则无法说明不为空的部分究竟是第几部分。比如， Clobber/Modify，Output为空，而Input不为空，则Clobber/Modify前的冒号必须省略（前面的规则），而Output 前的冒号必须为保留。如果Clobber/Modify不为空，而Input和Output都为空，则Input和Output前的冒号都必须保留。比如 __asm__( " mov %%eax, %%ebx" : : "a"(foo) )和__asm__( " mov %%eax, %%ebx" : : : "ebx" )。
从上面的规则可以看到另外一个事实，区分一个内联汇编是基本格式的还是带有C/C++表达式格式的，其规则在于在"Instruction List"后是否有冒号(:)的存在，如果没有则是基本格式的，否则，则是带有C/C++表达式格式的。
两种格式对寄存器语法的要求不同：基本格式要求寄存器前只能使用一个百分号(%)，这一点和非内联汇编相同；而带有C/C++表达式格式则要求寄存器前必须使用两个百分号(%%)，其原因我们会在后面讨论。
1. Output
Output用来指定当前内联汇编语句的输出。我们看一看这个例子：
__asm__("movl %%cr0, %0": "=a" (cr0));
这个内联汇编语句的输出部分为"=r"(cr0)，它是一个“操作表达式”，指定了一个输出操作。我们可以很清楚得看到这个输出操作由两部分组成： 括号括住的部分(cr0)和引号引住的部分"=a"。这两部分都是每一个输出操作必不可少的。括号括住的部分是一个C/C++表达式，用来保存内联汇编的 一个输出值，其操作就等于C/C++的相等赋值cr0 = output_value，因此，括号中的输出表达式只能是C/C++的左值表达式，也就是说它只能是一个可以合法的放在C/C++赋值操作中等号(=) 左边的表达式。那么右值output_value从何而来呢？
答案是引号中的内容，被称作“操作约束”（Operation Constraint），在这个例子中操作约束为"=a"，它包含两个约束：等号(=)和字母a，其中等号(=)说明括号中左值表达式cr0是一个 Write-Only的，只能够被作为当前内联汇编的输入，而不能作为输入。而字母a是寄存器EAX / AX / AL的简写，说明cr0的值要从eax寄存器中获取，也就是说cr0 = eax，最终这一点被转化成汇编指令就是movl %eax, address_of_cr0。现在你应该清楚了吧，操作约束中会给出：到底从哪个寄存器传递值给cr0。
另外，需要特别说明的是，很多文档都声明，所有输出操作的操作约束必须包含一个等号(=)，但GCC的文档中却很清楚的声明，并非如此。因为等号 (=)约束说明当前的表达式是一个 Write-Only的，但另外还有一个符号——加号(+)用来说明当前表达式是一个Read-Write的，如果一个操作约束中没有给出这两个符号中的 任何一个，则说明当前表达式是Read-Only的。因为对于输出操作来说，肯定是必须是可写的，而等号(=)和加号(+)都表示可写，只不过加号(+) 同时也表示是可读的。所以对于一个输出操作来说，其操作约束只需要有等号(=)或加号(+)中的任意一个就可以了。
二者的区别是：等号(=)表示当前操作表达式指定了一个纯粹的输出操作，而加号(+)则表示当前操作表达式不仅仅只是一个输出操作还是一个输入操作。但无论是等号(=)约束还是加号(+)约束所约束的操作表达式都只能放在Output域中，而不能被用在Input域中。
另外，有些文档声明：尽管GCC文档中提供了加号(+)约束，但在实际的编译中通不过；我不知道老版本会怎么样，我在GCC 2.96中对加号(+)约束的使用非常正常。
我们通过一个例子看一下，在一个输出操作中使用等号(=)约束和加号(+)约束的不同。
$ cat example2.c
int main(int __argc, char* __argv[])
{
int cr0 = 5;
__asm__ __volatile__("movl %%cr0, %0":"=a" (cr0));
return 0;
}
$ gcc -S example2.c
$ cat example2.s
main:
pushl %ebp
movl %esp, %ebp
subl $4, %esp
movl $5, -4(%ebp) # cr0 = 5
#APP
movl %cr0, %eax
#NO_APP
movl %eax, %eax
movl %eax, -4(%ebp) # cr0 = %eax
movl $0, %eax
leave
ret
这个例子是使用等号(=)约束的情况，变量cr0被放在内存-4(%ebp)的位置，所以指令mov %eax, -4(%ebp)即表示将%eax的内容输出到变量cr0中。
下面是使用加号(+)约束的情况：
$ cat example3.c
int main(int __argc, char* __argv[])
{
int cr0 = 5;
__asm__ __volatile__("movl %%cr0, %0" : "+a" (cr0));
return 0;
}
$ gcc -S example3.c
$ cat example3.s
main:
pushl %ebp
movl %esp, %ebp
subl $4, %esp
movl $5, -4(%ebp) # cr0 = 5
movl -4(%ebp), %eax # input ( %eax = cr0 )
#APP
movl %cr0, %eax
#NO_APP
movl %eax, -4(%ebp) # output (cr0 = %eax )
movl $0, %eax
leave
ret
从编译的结果可以看出，当使用加号(+)约束的时候，cr0不仅作为输出，还作为输入，所使用寄存器都是寄存器约束(字母a，表示使用eax寄存器)指定的。关于寄存器约束我们后面讨论。
在Output域中可以有多个输出操作表达式，多个操作表达式中间必须用逗号(,)分开。例如：
__asm__(
"movl %%eax, %0 \n\t"
"pushl %%ebx \n\t"
"popl %1 \n\t"
"movl %1, %2"
: "+a"(cr0), "=b"(cr1), "=c"(cr2));
2、Input
Input域的内容用来指定当前内联汇编语句的输入。我们看一看这个例子：
__asm__("movl %0, %%db7" : : "a" (cpu->db7));
例中Input域的内容为一个表达式"a"[cpu->db7)，被称作“输入表达式”，用来表示一个对当前内联汇编的输入。
像输出表达式一样，一个输入表达式也分为两部分：带括号的部分(cpu->db7)和带引号的部分"a"。这两部分对于一个内联汇编输入表达式来说也是必不可少的。
括号中的表达式cpu->db7是一个C/C++语言的表达式，它不必是一个左值表达式，也就是说它不仅可以是放在C/C++赋值操作左边的 表达式，还可以是放在C/C++赋值操作右边的表达式。所以它可以是一个变量，一个数字，还可以是一个复杂的表达式（比如a+b/c*d）。比如上例可以 改为： __asm__("movl %0, %%db7" : : "a" (foo))，__asm__("movl %0, %%db7" : : "a" (0x1000))或__asm__("movl %0, %%db7" : : "a" (va*vb/vc))。
引号号中的部分是约束部分，和输出表达式约束不同的是，它不允许指定加号(+)约束和等号(=)约束，也就是说它只能是默认的Read-Only 的。约束中必须指定一个寄存器约束，例中的字母a表示当前输入变量cpu->db7要通过寄存器eax输入到当前内联汇编中。
我们看一个例子：
$ cat example4.c
int main(int __argc, char* __argv[])
{
int cr0 = 5;
__asm__ __volatile__("movl %0, %%cr0"::"a" (cr0));
return 0;
}
$ gcc -S example4.c
$ cat example4.s
main:
pushl %ebp
movl %esp, %ebp
subl $4, %esp
movl $5, -4(%ebp) # cr0 = 5
movl -4(%ebp), %eax # %eax = cr0
#APP
movl %eax, %cr0
#NO_APP
movl $0, %eax
leave
ret
我们从编译出的汇编代码可以看到，在"Instruction List"之前，GCC按照我们的输入约束"a"，将变量cr0的内容装入了eax寄存器。
3. Operation Constraint
每一个Input和Output表达式都必须指定自己的操作约束Operation Constraint，我们这里来讨论在80386平台上所可能使用的操作约束。
1、寄存器约束
当你当前的输入或输入需要借助一个寄存器时，你需要为其指定一个寄存器约束。你可以直接指定一个寄存器的名字，比如：
__asm__ __volatile__("movl %0, %%cr0"::"eax" (cr0));
也可以指定一个缩写，比如：
__asm__ __volatile__("movl %0, %%cr0"::"a" (cr0));
如果你指定一个缩写，比如字母a，则GCC将会根据当前操作表达式中C/C++表达式的宽度决定使用%eax，还是%ax或%al。比如：
unsigned short __shrt;
__asm__ ("mov %0，%%bx" : : "a"(__shrt));
由于变量__shrt是16-bit short类型，则编译出来的汇编代码中，则会让此变量使用%ex寄存器。编译结果为：
movw -2(%ebp), %ax # %ax = __shrt
#APP
movl %ax, %bx
#NO_APP
无论是Input，还是Output操作表达式约束，都可以使用寄存器约束。
下表中列出了常用的寄存器约束的缩写。
约束 Input/Output 意义
r I,O 表示使用一个通用寄存器，由GCC在%eax/%ax/%al, %ebx/%bx/%bl, %ecx/%cx/%cl, %edx/%dx/%dl中选取一个GCC认为合适的。
q I,O 表示使用一个通用寄存器，和r的意义相同。
a I,O 表示使用%eax / %ax / %al
b I,O 表示使用%ebx / %bx / %bl
c I,O 表示使用%ecx / %cx / %cl
d I,O 表示使用%edx / %dx / %dl
D I,O 表示使用%edi / %di
S I,O 表示使用%esi / %si
f I,O 表示使用浮点寄存器
t I,O 表示使用第一个浮点寄存器
u I,O 表示使用第二个浮点寄存器
2、内存约束
如果一个Input/Output操作表达式的C/C++表达式表现为一个内存地址，不想借助于任何寄存器，则可以使用内存约束。比如：
__asm__ ("lidt %0" : "=m"(__idt_addr)); 或 __asm__ ("lidt %0" : :"m"(__idt_addr));
我们看一下它们分别被放在一个C源文件中，然后被GCC编译后的结果：
$ cat example5.c
// 本例中，变量sh被作为一个内存输入
int main(int __argc, char* __argv[])
{
char* sh = (char*)&__argc;
__asm__ __volatile__("lidt %0" : : "m" (sh));
return 0;
}
$ gcc -S example5.c
$ cat example5.s
main:
pushl %ebp
movl %esp, %ebp
subl $4, %esp
leal 8(%ebp), %eax
movl %eax, -4(%ebp) # sh = (char*) &__argc
#APP
lidt -4(%ebp)
#NO_APP
movl $0, %eax
leave
ret
$ cat example6.c
// 本例中，变量sh被作为一个内存输出
int main(int __argc, char* __argv[])
{
char* sh = (char*)&__argc;
__asm__ __volatile__("lidt %0" : "=m" (sh));
return 0;
}
$ gcc -S example6.c
$ cat example6.s
main:
pushl %ebp
movl %esp, %ebp
subl $4, %esp
leal 8(%ebp), %eax
movl %eax, -4(%ebp) # sh = (char*) &__argc
#APP
lidt -4(%ebp)
#NO_APP
movl $0, %eax
leave
ret
首先，你会注意到，在这两个例子中，变量sh没有借助任何寄存器，而是直接参与了指令lidt的操作。
其次，通过仔细观察，你会发现一个惊人的事实，两个例子编译出来的汇编代码是一样的！虽然，一个例子中变量sh作为输入，而另一个例子中变量sh作为输出。这是怎么回事？
原来，使用内存方式进行输入输出时，由于不借助寄存器，所以GCC不会按照你的声明对其作任何的输入输出处理。GCC只会直接拿来用，究竟对这个C/C++表达式而言是输入还是输出，完全依赖与你写在"Instruction List"中的指令对其操作的指令。
由于上例中，对其操作的指令为lidt，lidt指令的操作数是一个输入型的操作数，所以事实上对变量sh的操作是一个输入操作，即使你把它放在 Output域也不会改变这一点。所以，对此例而言，完全符合语意的写法应该是将sh放在Input域，尽管放在Output域也会有正确的执行结果。
所以，对于内存约束类型的操作表达式而言，放在Input域还是放在Output域，对编译结果是没有任何影响的，因为本来我们将一个操作表达式放 在 Input域或放在Output域是希望GCC能为我们自动通过寄存器将表达式的值输入或输出。既然对于内存约束类型的操作表达式来说，GCC不会自动为 它做任何事情，那么放在哪儿也就无所谓了。但从程序员的角度而言，为了增强代码的可读性，最好能够把它放在符合实际情况的地方。
约束 Input/Output 意义
m I,O 表示使用系统所支持的任何一种内存方式，不需要借助寄存器
3、立即数约束
如果一个Input/Output操作表达式的C/C++表达式是一个数字常数，不想借助于任何寄存器，则可以使用立即数约束。
由于立即数在C/C++中只能作为右值，所以对于使用立即数约束的表达式而言，只能放在Input域。
比如：__asm__ __volatile__("movl %0, %%eax" : : "i" (100) );
立即数约束很简单，也很容易理解，我们在这里就不再赘述。
约束 Input/Output 意义
i I 表示输入表达式是一个立即数(整数)，不需要借助任何寄存器
F I 表示输入表达式是一个立即数(浮点数)，不需要借助任何寄存器
4、通用约束
约束 Input/Output 意义
g I,O 表示可以使用通用寄存器，内存，立即数等任何一种处理方式。
0,1,2,3,4,5,6,7,8,9 I 表示和第n个操作表达式使用相同的寄存器/内存。
通用约束g是一个非常灵活的约束，当程序员认为一个C/C++表达式在实际的操作中，究竟使用寄存器方式，还是使用内存方式或立即数方式并无所谓 时，或者程序员想实现一个灵活的模板，让GCC可以根据不同的C/C++表达式生成不同的访问方式时，就可以使用通用约束g。比如：
#define JUST_MOV(foo) __asm__ ("movl %0, %%eax" : : "g"(foo))
JUST_MOV(100)和JUST_MOV(var)则会让编译器产生不同的代码。
int main(int __argc, char* __argv[])
{
JUST_MOV(100);
return 0;
}
编译后生成的代码为：
main:
pushl %ebp
movl %esp, %ebp
#APP
movl $100, %eax
#NO_APP
movl $0, %eax
popl %ebp
ret
很明显这是立即数方式。而下一个例子：
int main(int __argc, char* __argv[])
{
JUST_MOV(__argc);
return 0;
}
经编译后生成的代码为：
main:
pushl %ebp
movl %esp, %ebp
#APP
movl 8(%ebp), %eax
#NO_APP
movl $0, %eax
popl %ebp





















AT&T汇编语言与GCC内嵌汇编简介  

2010-03-04 13:42:02|  分类： linux 命令 |举报|字号 订阅
AT&T汇编语言与GCC内嵌汇编简介
版本 0.1
时间04/3/30
EMAIL chforest_chang@hotmail.com
1 AT&T与INTEL的汇编语言语法的区别.........................................3
1.1 大小写...........................................................3
1.2 操作数赋值方向...................................................3
1.3 前缀.............................................................3
1.4 间接寻址语法.....................................................4
1.5 后缀.............................................................4
1.6 指令.............................................................5
2 GCC内嵌汇编.............................................................5
2.1 简介.............................................................5
2.2 内嵌汇编举例.....................................................5
2.3 语法.............................................................7
2.3.1 汇编语句模板.................................................7
2.3.2 输出部分.....................................................7
2.3.3 输入部分.....................................................8
2.3.4 限制字符.....................................................8
2.3.5 破坏描述部分................................................14
2.4 GCC如何编译内嵌汇编代码.........................................19
3 后记....................................................................20
本节先介绍AT&T 汇编语言语法与INTEL 汇编语法的差别，然后介绍GCC内嵌汇编语法。
阅读本节需要读者具有INTEL汇编语言基础。
1 AT&T与INTEL的汇编语言语法的区别
1.1 大小写
INTEL格式的指令使用大写字母，而AT&T格式的使用小写字母。
例：
INTEL AT&T
MOV EAX,EBX movl %ebx,%eax
1.2 操作数赋值方向
在INTEL语法中，第一个表示目的操作数，第二个表示源操作数，赋值方向从右向左。
AT&T语法第一个为源操作数，第二个为目的操作数，方向从左到右，合乎自然。
例：
INTEL AT&T
MOV EAX,EBX movl %ebx,%eax
1.3 前缀
在 INTEL 语法中寄存器和立即数不需要前缀；AT&T 中寄存器需要加前缀“%”；立即数
需要加前缀“$”。
例：
INTEL AT&T
MOV EAX,1 movl $1,%eax
符号常数直接引用，不需要加前缀，如：movl value , %ebx，value为一常数；在符
号前加前缀$表示引用符号地址, 如movl $value, %ebx，是将value的地址放到ebx中。
总线锁定前缀“lock”：总线锁定操作。“lock”前缀在Linux 核心代码中使用很多，特
别是SMP代码中。当总线锁定后其它CPU不能存取锁定地址处的内存单元。
远程跳转指令和子过程调用指令的操作码使用前缀“l“，分别为ljmp，lcall，与之
相应的返回指令伪lret。
例：
INTEL AT&T
CALL FAR SECTION:OFFSET lcall $secion:$offset
JMP FAR SECTION:OFFSET ljmp $secion:$offset
RET FAR SATCK_ADJUST lret $stack_adjust
1.4 间接寻址语法
INTEL 中基地址使用“[”、“]”，而在AT&T 中使用“(”、“)”；另外处理复杂操作数的
语法也不同， INTEL 为Segreg:[base+index*scale+disp] ， 而在AT&T 中为
%segreg:disp(base,index,sale)，其中segreg，index，scale，disp都是可选的，在指定
index而没有显式指定Scale的情况下使用默认值1。Scale和disp不需要加前缀“&”。
INTEL AT&T
Instr
foo,segreg:[base+index*scale+disp]
instr
%segreg:disp(base,index,scale),foo
1.5 后缀
AT&T 语法中大部分指令操作码的最后一个字母表示操作数大小，“b”表示byte（一个
字节）；“w”表示word（2 个字节）；“l”表示long（4 个字节）。INTEL 中处理内存操作数
时也有类似的语法如：BYTE PTR、WORD PTR、DWORD PTR。
例：
INTEL AT&T
mov al, bl movb %bl,%al
mov ax,bx movw %bx,%ax
mov eax, dword ptr [ebx] movl (%ebx), %eax
在 AT&T 汇编指令中，操作数扩展指令有两个后缀，一个指定源操作数的字长，另一个
指定目标操作数的字长。AT&T 的符号扩展指令的为“movs”，零扩展指令为“movz”（相应
的Intel指令为“movsx”和“movzx”）。因此，“movsbl %al,%edx”表示对寄存器al 中的
字节数据进行字节到长字的符号扩展，计算结果存放在寄存器edx中。下面是一些允许的操
作数扩展后缀：
l  bl: 字节->长字
l  bw: 字节->字
l  wl: 字->长字
跳转指令标号后的后缀表示跳转方向，“f”表示向前（forward），“b”表示向后（back）。
例：
jmp 1f
1: jmp 1f
1:
1.6 指令
INTEL 汇编与AT&T 汇编指令基本相同，差别仅在语法上。关于每条指令的语法可以参
考I386 Manual。
2 GCC内嵌汇编
2.1 简介
内核代码绝大部分使用C语言编写，只有一小部分使用汇编语言编写，例如与特定体系
结构相关的代码和对性能影响很大的代码。GCC提供了内嵌汇编的功能，可以在C 代码中直
接内嵌汇编语言语句，大大方便了程序设计。
简单的内嵌汇编很容易理解
例：
__asm__ __volatile__("hlt");
“__asm__”表示后面的代码为内嵌汇编，“asm”是“__asm__”的别名。“__volatile__”
表示编译器不要优化代码，后面的指令保留原样，“volatile”是它的别名。括号里面是汇
编指令。
2.2 内嵌汇编举例
在内嵌汇编中，可以将C语言表达式指定为汇编指令的操作数，而且不用去管如何将C
语言表达式的值读入哪个寄存器，以及如何将计算结果写回C 变量，你只要告诉程序中C
语言表达式与汇编指令操作数之间的对应关系即可， GCC会自动插入代码完成必要的操作。
使用内嵌汇编，要先编写汇编指令模板，然后将C语言表达式与指令的操作数相关联，
并告诉GCC对这些操作有哪些限制条件。例如在下面的汇编语句：
__asm__ __violate__ ("movl %1,%0" : "=r" (result) : "m" (input));
“movl %1,%0”是指令模板；“%0”和“%1”代表指令的操作数，称为占位符，内嵌汇
编靠它们将C 语言表达式与指令操作数相对应。指令模板后面用小括号括起来的是C语言表
达式，本例中只有两个：“result”和“input”，他们按照出现的顺序分别与指令操作数“%0”，
“%1”对应；注意对应顺序：第一个C 表达式对应“%0”；第二个表达式对应“%1”，依次类
推，操作数至多有10 个，分别用“%0”,“%1”….“%9”表示。在每个操作数前面有一个
用引号括起来的字符串，字符串的内容是对该操作数的限制或者说要求。“result”前面的
限制字符串是“=r”，其中“=”表示“result”是输出操作数，“r”表示需要将“result”
与某个通用寄存器相关联，先将操作数的值读入寄存器，然后在指令中使用相应寄存器，而
不是“result”本身，当然指令执行完后需要将寄存器中的值存入变量“result”，从表面
上看好像是指令直接对“result”进行操作，实际上GCC做了隐式处理，这样我们可以少写
一些指令。“input”前面的“r”表示该表达式需要先放入某个寄存器，然后在指令中使用
该寄存器参加运算。
我们将上面的内嵌代码放到一个C 源文件中，然后使用gcc –c –S 得到该C 文件源代码
相对应的汇编代码，然后查看一下汇编代码，看看GCC是如何处理的。
C源文件如下内容如下，注意该代码没有实际意义，仅仅作为例子。
extern int input,result;
void test(void)
{
input = 1;
__asm__ __volatile__ ("movl %1,%0" : "=r" (result) : "r" (input));
return ;
}
对应的汇编代码如下;
行号 代码 解释
1－7 ……
8 movl $1, input 对应C语言语句input = 1;
9 movl input, %eax
10 #APP GCC插入的注释，表示内嵌汇编开始
11 movl %eax,%eax 我们的内嵌汇编语句
12 #NO_APP GCC插入的注释，表示内嵌汇编结束
13 movl %eax, result 将结果存入result变量
14－18 。。。。。。
从汇编代码可以看出，第9 行和第13 行是GCC 自动增加的代码，GCC 根据限定字符串
决定如何处理C表达式，本例两个表达式都被指定为“r”型，所以先使用指令：
movl input, %eax
将input读入寄存器%eax；GCC也指定一个寄存器与输出变量result相关，本例也是%eax，
等得到操作结果后再使用指令：
movl %eax, result
将寄存器的值写回C 变量result 中。从上面的汇编代码我们可以看出与result 和input
相关连的寄存器都是%eax，GCC使用%eax替换内嵌汇编指令模板中的%0，%1：
movl %eax,%eax
显然这一句可以不要。但是没有优化，所以这一句没有被去掉。
由此可见，C表达式或者变量与寄存器的关系由GCC自动处理，我们只需使用限制字符
串指导GCC如何处理即可。限制字符必须与指令对操作数的要求相匹配，否则产生的汇编代
码将会有错，读者可以将上例中的两个“r”，都改为“m”(m表示操作数放在内存，而不是
寄存器中)，编译后得到的结果是：
movl input, result
很明显这是一条非法指令，因此限制字符串必须与指令对操作数的要求匹配。例如指令movl
允许寄存器到寄存器，立即数到寄存器等，但是不允许内存到内存的操作，因此两个操作数
不能同时使用“m”作为限定字符。
2.3 语法
内嵌汇编语法如下：
__asm__(汇编语句模板: 输出部分: 输入部分: 破坏描述部分)
共四个部分：汇编语句模板，输出部分，输入部分，破坏描述部分，各部分使用“:”
格开，汇编语句模板必不可少，其他三部分可选，如果使用了后面的部分，而前面部分为空，
也需要用“:”格开，相应部分内容为空。例如：
__asm__ __volatile__("cli": : :"memory")
2.3.1 汇编语句模板
汇编语句模板由汇编语句序列组成，语句之间使用“;”、“\n”或“\n\t”分开。指令
中的操作数可以使用占位符引用C语言变量，操作数占位符最多10个，名称如下：%0，%1，…，
%9。指令中使用占位符表示的操作数，总被视为long型（4个字节），但对其施加的操作根
据指令可以是字或者字节，当把操作数当作字或者字节使用时，默认为低字或者低字节。对
字节操作可以显式的指明是低字节还是次字节。方法是在%和序号之间插入一个字母，“b”
代表低字节，“h”代表高字节，例如：%h1。
2.3.2 输出部分
输出部分描述输出操作数，不同的操作数描述符之间用逗号格开，每个操作数描述符由
限定字符串和C 语言变量组成。每个输出操作数的限定字符串必须包含“=”表示他是一个
输出操作数。
例：
__asm__ __volatile__("pushfl ; popl %0 ; cli":"=g" (x) )
描述符字符串表示对该变量的限制条件，这样GCC 就可以根据这些条件决定如何分配寄
存器，如何产生必要的代码处理指令操作数与C表达式或C变量之间的联系。
2.3.3 输入部分
输入部分描述输入操作数，不同的操作数描述符之间使用逗号格开，每个操作数描述符
由限定字符串和C语言表达式或者C语言变量组成。。
例 1：
__asm__ __volatile__ ("lidt %0" : : "m" (real_mode_idt));
例二（bitops.h）：
Static __inline__ void __set_bit(int nr, volatile void * addr)
{
__asm__(
"btsl %1,%0"
:"=m" (ADDR)
:"Ir" (nr));
}
后例功能是将(*addr)的第nr位设为1。第一个占位符%0与C 语言变量ADDR对应，第
二个占位符%1与C语言变量nr对应。因此上面的汇编语句代码与下面的伪代码等价：btsl
nr, ADDR，该指令的两个操作数不能全是内存变量，因此将nr的限定字符串指定为“Ir”，
将nr 与立即数或者寄存器相关联，这样两个操作数中只有ADDR为内存变量。
2.3.4 限制字符
2.3.4.1 限制字符列表
限制字符有很多种，有些是与特定体系结构相关，此处仅列出常用的限定字符和i386
中可能用到的一些常用的限定符。它们的作用是指示编译器如何处理其后的C语言变量与指
令操作数之间的关系，例如是将变量放在寄存器中还是放在内存中等，下表列出了常用的限
定字母。
分类限定符描述
“a” 将输入变量放入eax
这里有一个问题：假设eax已经被使用，那怎么办？
其实很简单：因为GCC 知道eax 已经被使用，它在这段汇编代码
的起始处插入一条语句pushl %eax，将eax 内容保存到堆栈，然
后在这段代码结束处再增加一条语句popl %eax，恢复eax的内容
“b” 将输入变量放入ebx
“c” 将输入变量放入ecx
“d” 将输入变量放入edx
“s” 将输入变量放入esi
通用寄存
器
“d” 将输入变量放入edi
“q” 将输入变量放入eax，ebx，ecx，edx中的一个
“r” 将输入变量放入通用寄存器，也就是eax，ebx，ecx，edx，esi，
edi中的一个
“A” 把 eax和edx合成一个64 位的寄存器(use long longs)
“m” 内存变量
“o” 操作数为内存变量，但是其寻址方式是偏移量类型，也即是基址
寻址，或者是基址加变址寻址
“V” 操作数为内存变量，但寻址方式不是偏移量类型
“ ” 操作数为内存变量，但寻址方式为自动增量
内存
“p” 操作数是一个合法的内存地址（指针）
“g” 将寄存器或输入变量放入eax，ebx，ecx，edx中的一个或者作为内存变量
内存“X” 操作数可以是任何类型
“I” 0-31之间的立即数（用于32位移位指令）
“J” 0-63之间的立即数（用于64位移位指令）
“N” 0-255之间的立即数（用于out指令）
“i” 立即数
立即数
“n” 立即数，有些系统不支持除字以外的立即数，这些系统应该使用
“n”而不是“i”
匹配 “ 0 ” ，
“1” ...
“9”
表示用它限制的操作数与某个指定的操作数匹配，也即该操作数
就是指定的那个操作数，例如用“0”去描述“％1”操作数，那
么“%1”引用的其实就是“%0”操作数，注意作为限定符字母的0
－9 与指令中的“％0”－“％9”的区别，前者描述操作数，后者
代表操作数。
后面有详细描述
& 该输出操作数不能使用过和输入操作数相同的寄存器
后面有详细描述
操作数类“=” 操作数在指令中是只写的（输出操作数）
型“+” 操作数在指令中是读写类型的（输入输出操作数）
“f” 浮点寄存器
“t” 第一个浮点寄存器
“u” 第二个浮点寄存器
浮点数
“G” 标准的80387浮点常数
% 该操作数可以和下一个操作数交换位置
例如addl的两个操作数可以交换顺序（当然两个操作数都不能是
立即数）
# 部分注释，从该字符到其后的逗号之间所有字母被忽略
* 表示如果选用寄存器，则其后的字母被忽略
现在继续看上面的例子，"=m" (ADDR)表示ADDR 为内存变量（“m”），而且是输出变量
（“=”）；"Ir" (nr)表示nr为0－31之间的立即数（“I”）或者一个寄存器操作数（“r”）。
2.3.4.2 匹配限制符
I386 指令集中许多指令的操作数是读写型的（读写型操作数指先读取原来的值然后参
加运算，最后将结果写回操作数），例如addl %1,%0，它的作用是将操作数%0 与操作数%1
的和存入操作数%0，因此操作数%0 是读写型操作数。老版本的GCC 对这种类型操作数的支
持不是很好，它将操作数严格分为输入和输出两种，分别放在输入部分和输出部分，而没有
一个单独部分描述读写型操作数，因此在GCC 中读写型的操作数需要在输入和输出部分分别
描述，靠匹配限制符将两者关联到一起。注意仅在输入和输出部分使用相同的C 变量，但是
不用匹配限制符，产生的代码很可能不对，后面会分析原因。
匹配限制符是一位数字：“0”、“1”……“9”，分别表示它限制的C 表达式分别与占位
符%0，%1……%9对应的C变量匹配。例如使用“0”作为%1 的限制字符，那么%0 和％1 表示
同一个C变量。
看一下下面的代码就知道为什么要将读写型操作数，分别在输入和输出部分加以描述。
该例功能是求input+result的和，然后存入result：
extern int input,result;
void test_at_t()
{
result = 0;
input = 1;
__asm__ __volatile__ ("addl %1,%0":"=r"(result): "r"(input));
}
对应的汇编代码为：
movl $0,_result
movl $1,_input
movl _input,%edx
/APP
addl %edx,%eax
/NO_APP
movl %eax,%edx
movl %edx,_result
input为输入型变量，而且需要放在寄存器中，GCC 给它分配的寄存器是%edx，在执行
addl之前%edx的内容已经是input 的值。可见对于使用“r”限制的输入型变量或者表达式，
在使用之前GCC会插入必要的代码将他们的值读到寄存器；“m ”型变量则不需要这一步。读
入input后执行addl，显然%eax 的值不对，需要先读入result的值才行。再往后看：movl
%eax,%edx 和movl %edx,_result的作用是将结果存回result，分配给result的寄存器与
分配给input的一样，都是%edx。
综上可以总结出如下几点：
1. 使用“r”限制的输入变量，GCC 先分配一个寄存器，然后将值读入寄存器，最后
用该寄存器替换占位符；
2. 使用“r”限制的输出变量，GCC会分配一个寄存器，然后用该寄存器替换占位符，
但是在使用该寄存器之前并不将变量值先读入寄存器，GCC认为所有输出变量以前
的值都没有用处，不读入寄存器（可能是因为AT&T汇编源于CISC架构处理器的汇
编语言，在CISC处理器中大部分指令的输入输出明显分开，而不像RISC那样一个
操作数既做输入又做输出，例如add r0,r1,r2，r0 和r1 是输入，r2 是输出，输
入和输出分开，没有使用输入输出型操作数，这样我们就可以认为r2 对应的操作
数原来的值没有用处，也就没有必要先将操作数的值读入r2，因为这是浪费处理
器的CPU周期），最后GCC插入代码，将寄存器的值写回变量；
3. 输入变量使用的寄存器在最后一处使用它的指令之后，就可以挪做其他用处，因为
已经不再使用。例如上例中的%edx。在执行完addl之后就作为与result对应的寄
存器。
因为第二条，上面的内嵌汇编指令不能奏效，因此需要在执行addl 之前把result的值
读入寄存器，也许再将result放入输入部分就可以了（因为第一条会保证将result先读入
寄存器）。修改后的指令如下（为了更容易说明问题将input限制符由“r”改为“m”）：
extern int input,result;
void test_at_t()
{
result = 0;
input = 1;
__asm__ __volatile__ ("addl %2,%0":"=r"(result):"r"(result),"m"(input));
}
看上去上面的代码可以正常工作，因为我们知道%0和%1都和result相关，应该使用同
一个寄存器，但是GCC并不去判断%0 和%1 是否和同一个C 表达式或变量相关联（这样易于
产生与内嵌汇编相应的汇编代码），因此%0和%1使用的寄存器可能不同。我们看一下汇编代
码就知道了。
movl $0,_result
movl $1,_input
movl _result,%edx
/APP
addl _input,%eax
/NO_APP
movl %eax,%edx
movl %edx,_result
现在在执行addl之前将result的值被读入了寄存器%edx，但是addl 指令的操作数%0
却成了%eax，而不是%edx，与预料的不同，这是因为GCC给输出和输入部分的变量分配了不
同的寄存器，GCC没有去判断两者是否都与result相关，后面会讲GCC 如何翻译内嵌汇编，
看完之后就不会惊奇啦。
使用匹配限制符后，GCC 知道应将对应的操作数放在同一个位置（同一个寄存器或者同
一个内存变量）。使用匹配限制字符的代码如下：
extern int input,result;
void test_at_t()
{
result = 0;
input = 1;
__asm__ __volatile__ ("addl %2,%0":"=r"(result):"0"(result),"m"(input));
}
输入部分中的result用匹配限制符“0”限制，表示%1与％0代表同一个变量，输入部
分说明该变量的输入功能，输出部分说明该变量的输出功能，两者结合表示result 是读写
型。因为%0和%1表示同一个C变量，所以放在相同的位置，无论是寄存器还是内存。
相应的汇编代码为：
movl $0,_result
movl $1,_input
movl _result,%edx
movl %edx,%eax
/APP
addl _input,%eax
/NO_APP
movl %eax,%edx
movl %edx,_result
可以看到与result相关的寄存器是%edx，在执行指令addl 之前先从%edx 将result读
入%eax，执行之后需要将结果从%eax读入%edx，最后存入result中。这里我们可以看出GCC
处理内嵌汇编中输出操作数的一点点信息：addl 并没有使用%edx，可见它不是简单的用
result 对应的寄存器%edx 去替换%0，而是先分配一个寄存器，执行运算，最后才将运算结
果存入对应的变量，因此GCC是先看该占位符对应的变量的限制符，发现是一个输出型寄存
器变量，就为它分配一个寄存器，此时没有去管对应的C变量，最后GCC知道还要将寄存器
的值写回变量，与此同时，它发现该变量与%edx关联，因此先存入%edx，再存入变量。
至此读者应该明白了匹配限制符的意义和用法。在新版本的GCC中增加了一个限制字符
“+”，它表示操作数是读写型的，GCC知道应将变量值先读入寄存器，然后计算，最后写回
变量，而无需在输入部分再去描述该变量。
例;
extern int input,result;
void test_at_t()
{
result = 0;
input = 1;
__asm__ __volatile__ ("addl %1,%0":"+r"(result):"m"(input));
}
此处用“+”替换了“=”，而且去掉了输入部分关于result的描述，产生的汇编代码如
下：
movl $0,_result
movl $1,_input
movl _result,%eax
/APP
addl _input,%eax
/NO_APP
movl %eax,_result
L2:
movl %ebp,%esp
处理的比使用匹配限制符的情况还要好，省去了好几条汇编代码。
2.3.4.3 “&”限制符
限制符“&”在内核中使用的比较多，它表示输入和输出操作数不能使用相同的寄存器，
这样可以避免很多错误。
举一个例子，下面代码的作用是将函数foo的返回值存入变量ret中：
__asm__ ( “call foo;movl %%edx,%1”, : ”=a”(ret) : ”r”(bar) );
我们知道函数的int 型返回值存放在%eax 中，但是gcc 编译的结果是输入和输出同时
使用了寄存器%eax，如下：
movl bar, %eax
#APP
call foo
movl %ebx,%eax
#NO_APP
movl %eax, ret
结果显然不对，原因是GCC 并不知道%eax 中的值是我们所要的。避免这种情况的方法
是使用“&”限定符，这样bar就不会再使用%eax寄存器，因为已被ret指定使用。
_asm__ ( “call foo;movl %%edx,%1”, : ”=&a”(ret) : ”r”(bar) );
2.3.5 破坏描述部分
2.3.5.1 寄存器破坏描述符
通常编写程序只使用一种语言：高级语言或者汇编语言。高级语言编译的步骤大致如下：
l 预处理；
l 编译
l 汇编
l 链接
我们这里只关心第二步编译（将C 代码转换成汇编代码）：因为所有的代码都是用高级
语言编写，编译器可以识别各种语句的作用，在转换的过程中所有的寄存器都由编译器决定
如何分配使用，它有能力保证寄存器的使用不会冲突；也可以利用寄存器作为变量的缓冲区，
因为寄存器的访问速度比内存快很多倍。如果全部使用汇编语言则由程序员去控制寄存器的
使用，只能靠程序员去保证寄存器使用的正确性。但是如果两种语言混用情况就变复杂了，
因为内嵌的汇编代码可以直接使用寄存器，而编译器在转换的时候并不去检查内嵌的汇编代
码使用了哪些寄存器（因为很难检测汇编指令使用了哪些寄存器，例如有些指令隐式修改寄
存器，有时内嵌的汇编代码会调用其他子过程，而子过程也会修改寄存器），因此需要一种
机制通知编译器我们使用了哪些寄存器（程序员自己知道内嵌汇编代码中使用了哪些寄存
器），否则对这些寄存器的使用就有可能导致错误，修改描述部分可以起到这种作用。当然
内嵌汇编的输入输出部分指明的寄存器或者指定为“r”，“g”型由编译器去分配的寄存器就
不需要在破坏描述部分去描述，因为编译器已经知道了。
破坏描述符由逗号格开的字符串组成，每个字符串描述一种情况，一般是寄存器名；除
寄存器外还有“memory”。例如：“%eax”，“%ebx”，“memory”等。
下面看个例子就很清楚为什么需要通知GCC 内嵌汇编代码中隐式（称它为隐式是因为
GCC并不知道）使用的寄存器。
在内嵌的汇编指令中可能会直接引用某些寄存器，我们已经知道AT&T 格式的汇编语言
中，寄存器名以“%”作为前缀，为了在生成的汇编程序中保留这个“%”号，在asm语句中
对寄存器的引用必须用“%%”作为寄存器名称的前缀。原因是“%”在asm 内嵌汇编语句中
的作用与“\”在C语言中的作用相同，因此“%%”转换后代表“%”。
例（没有使用修改描述符）：
int main(void)
{
int input, output,temp;
input = 1;
__asm__ __volatile__ ("movl $0, %%eax;\n\t
movl %%eax, %1;\n\t
movl %2, %%eax;\n\t
movl %%eax, %0;\n\t"
:"=m"(output),"=m"(temp) /* output */
:"r"(input) /* input */
);
return 0;
}
这段代码使用%eax作为临时寄存器，功能相当于C代码：“temp = 0;output=input”，
对应的汇编代码如下：
movl $1,-4(%ebp)
movl -4(%ebp),%eax
/APP
movl $0, %eax;
movl %eax, -12(%ebp);
movl %eax, %eax;
movl %eax, -8(%ebp);
/NO_APP
显然GCC给input分配的寄存器也是%eax，发生了冲突，output的值始终为0，而不是
input。
使用破坏描述后的代码：
int main(void)
{
int input, output,temp;
input = 1;
__asm__ __volatile__ ("movl $0, %%eax;\n\t
movl %%eax, %1;\n\t
movl %2, %%eax;\n\t
movl %%eax, %0;\n\t"
:"=m"(output),"=m"(temp) /* output */
:"r"(input) /* input */
:"eax"); /* 描述符 */
return 0;
}
对应的汇编代码：
movl $1,-4(%ebp)
movl -4(%ebp),%edx
/APP
movl $0, %eax;
movl %eax, -12(%ebp);
movl %edx, %eax;
movl %eax, -8(%ebp);
/NO_APP
通过破坏描述部分，GCC得知%eax 已被使用，因此给input分配了%edx。在使用内嵌汇
编时请记住一点：尽量告诉GCC尽可能多的信息，以防出错。
如果你使用的指令会改变CPU的条件寄存器cc，需要在修改描述部分增加“cc”。
2.3.5.2 memory 破坏描述符
“memory”比较特殊，可能是内嵌汇编中最难懂部分。为解释清楚它，先介绍一下编译
器的优化知识，再看C关键字volatile。最后去看该描述符。
2.3.5.2.1 编译器优化介绍
内存访问速度远不及CPU处理速度，为提高机器整体性能，在硬件上引入硬件高速缓存
Cache，加速对内存的访问。另外在现代CPU中指令的执行并不一定严格按照顺序执行，没
有相关性的指令可以乱序执行，以充分利用CPU的指令流水线，提高执行速度。以上是硬件
级别的优化。再看软件一级的优化：一种是在编写代码时由程序员优化，另一种是由编译器
进行优化。编译器优化常用的方法有：将内存变量缓存到寄存器；调整指令顺序充分利用
CPU指令流水线，常见的是重新排序读写指令。
对常规内存进行优化的时候，这些优化是透明的，而且效率很好。由编译器优化或者硬
件重新排序引起的问题的解决办法是在从硬件（或者其他处理器）的角度看必须以特定顺序
执行的操作之间设置内存屏障（memory barrier），linux 提供了一个宏解决编译器的执行
顺序问题。
void Barrier(void)
这个函数通知编译器插入一个内存屏障，但对硬件无效，编译后的代码会把当前CPU寄存器
中的所有修改过的数值存入内存，需要这些数据的时候再重新从内存中读出。
2.3.5.2.2 C语言关键字volatile
C语言关键字volatile（注意它是用来修饰变量而不是上面介绍的__volatile__）表明
某个变量的值可能在外部被改变，因此对这些变量的存取不能缓存到寄存器，每次使用时需
要重新存取。该关键字在多线程环境下经常使用，因为在编写多线程的程序时，同一个变量
可能被多个线程修改，而程序通过该变量同步各个线程，例如：
DWORD __stdcall threadFunc(LPVOID signal)
{
int* intSignal=reinterpret_cast<int*>(signal);
*intSignal=2;
while(*intSignal!=1)
sleep(1000);
return 0;
}
该线程启动时将intSignal 置为2，然后循环等待直到intSignal 为1 时退出。显然
intSignal的值必须在外部被改变，否则该线程不会退出。但是实际运行的时候该线程却不
会退出，即使在外部将它的值改为1，看一下对应的伪汇编代码就明白了：
mov ax,signal
label:
if(ax!=1)
goto label
对于C编译器来说，它并不知道这个值会被其他线程修改。自然就把它cache在寄存器
里面。记住，C 编译器是没有线程概念的！这时候就需要用到volatile。volatile 的本意
是指：这个值可能会在当前线程外部被改变。也就是说，我们要在threadFunc中的intSignal
前面加上volatile关键字，这时候，编译器知道该变量的值会在外部改变，因此每次访问
该变量时会重新读取，所作的循环变为如下面伪码所示：
label:
mov ax,signal
if(ax!=1)
goto label
2.3.5.2.3 Memory
有了上面的知识就不难理解Memory修改描述符了，Memory描述符告知GCC：
l  1）不要将该段内嵌汇编指令与前面的指令重新排序；也就是在执行内嵌汇编代码
之前，它前面的指令都执行完毕
l  2）不要将变量缓存到寄存器，因为这段代码可能会用到内存变量，而这些内存变
量会以不可预知的方式发生改变，因此GCC插入必要的代码先将缓存到寄存器的变
量值写回内存，如果后面又访问这些变量，需要重新访问内存。
如果汇编指令修改了内存，但是GCC 本身却察觉不到，因为在输出部分没有描述，此时
就需要在修改描述部分增加“memory”，告诉GCC 内存已经被修改，GCC 得知这个信息后，
就会在这段指令之前，插入必要的指令将前面因为优化Cache 到寄存器中的变量值先写回内
存，如果以后又要使用这些变量再重新读取。
例：
………..
Char test[100];
char a;
char c;
c = 0;
test[0] = 1;
……..
a = test [0];
……
__asm__("cld\n\t"
"rep\n\t"
"stosb"
: /* no output */
: "a" (c),"D" (test),"c" (100)
: "cx","di","memory");
……….
//我们知道test[0]已经修改，所以重新读取
a=test[0];
……
这段代码中的汇编指令功能与memset相当，也就是相当于调用了memset(test,0,100)；
它使用stosb 修改了test数组的内容，但是没有在输入或输出部分去描述操作数，因为这
两条指令都不需要显式的指定操作数，因此需要增加“memory”通知GCC。现在假设：GCC
在优化时将test[0]放到了%eax 寄存器，那么test[0] = 1 对应于%eax=1，a = test [0]
被换为a=%eax，如果在那段汇编指令中不使用“memory”，Gcc 不知道现在test[0]的值已
经被改变了（如果整段代码都是我们自己使用汇编编写，我们自己当然知道这些内存的修改
情况，我们也可以人为的去优化，但是现在除了我们编写的那一小段外，其他汇编代码都是
GCC生成的，它并没有那么智能，知道这段代码会修改test[0]），结果其后的a=test[0]，
转换为汇编后却是a=%eax，因为GCC不知道显式的改变了test数组，结果出错了。如果增
加了“memory”修饰符，GCC 知道：“这段代码修改了内存，但是也仅此而已，它并不知道
到底修改了哪些变量”，因此他将以前因优化而缓存到寄存器的变量值全部写回内存，从内
嵌汇编开始，如果后面的代码又要存取这些变量，则重新存取内存（不会将读写操作映射到
以前缓存的那个寄存器）。这样上面那段代码最后一句就不再是%eax=1，而是test[0] = 1。
这两条对实现临界区至关重要，第一条保证不会因为指令的重新排序将临界区内的代码
调到临界区之外（如果临界区内的指令被重排序放到临界区之外，What will happen?），第
二条保证在临界区访问的变量的值，肯定是最新的值，而不是缓存在寄存器中的值，否则就
会导致奇怪的错误。例如下面的代码：
int del_timer(struct timer_list * timer)
{
int ret = 0;
if (timer->next) {
unsigned long flags;
struct timer_list * next;
save_flags(flags);
cli();
//临界区开始
if ((next = timer->next) != NULL) {
(next->prev = timer->prev)->next = next;
timer->next = timer->prev = NULL;
ret = 1;
}
//临界区结束
restore_flags(flags);
}
return ret;
}
它先判断timer->next的值，如果是空直接返回，无需进行下面的操作。如果不是空，
则进入临界区进行操作，但是cli()的实现（见下面）没有使用“memory”，timer->next
的值可能会被缓存到寄存器中，后面if ((next = timer->next) != NULL)会从寄存器中读
取timer->next的值，如果在if (timer->next)之后，进入临界区之前，timer->next的值
可能被在外部改变，这时肯定会出现异常情况，而且这种情况很难Debug。但是如果cli使
用“memory”，那么if ((next = timer->next) != NULL)语句会重新从内存读取timer->next
的值，而不会从寄存器中取，这样就不会出现问题啦。
2.4版内核中cli和sti的代码如下：
#define __cli() __asm__ __volatile__("cli": : :"memory")
#define __sti() __asm__ __volatile__("sti": : :"memory")
通过上面的例子，读者应该知道，为什么指令没有修改内存，但是却使用“memory”修
改描述符的原因了吧。应从指令的上下文去理解为什么要这样做。
使用“volatile”也可以达到这个目的，但是我们在每个变量前增加该关键字，不如使
用“memory”方便。
2.4 GCC 如何编译内嵌汇编代码
GCC编译内嵌汇编代码的步骤如下：
1. 输入变量与占位符
根据限定符和破坏描述部分，为输入和输出部分的变量分配合适的寄存器，如果限定符
指定为立即数(“i”)或内存变量(“m”)则不需要该步骤，如果限定符没有具体指定输入操
作数的类型(如“g”)，GCC 会视需要决定是否将该操作数输入到某个寄存器。这样每个占
位符都与某个寄存器、内存变量或立即数形成了一一对应的关系。对分配了寄存器的输入变
量需要增加代码将它的值读入寄存器。另外还要根据破坏描述符的部分增加额外代码。
2. 指令模板部分
然后根据这种一一对应的关系，用这些寄存器、内存变量或立即数来取代汇编代码中的
占位符。
3. 变量输出
按照输出限定符的指定将寄存器的内容输出到某个内存变量中，如果输出操作数的限定
符指定为内存变量(“m”)，则该步骤被省略。
3 后记
该文档参照了Web上的许多与GCC 内嵌汇编相关的文章编写而成，在此表示感谢，如有
问题请发Email至：chforest_chang@hotmail.com 一起讨论。