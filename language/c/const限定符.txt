const 限定一个对象为只读属性。
const使用的基本形式： const type m;限定m不可变。例如:
const int *p; /*限定*p不可变，即指针指向的内容不可变，但指针本身可变。*/

主要用途
1）可以定义const常量，具有不可变性。 
   例如：const int Max=100; Max++会产生错误; 
2）便于进行类型检查，使编译器对处理内容有更多了解，消除了一些隐患。
   例如： void f(const int i) { .........} 编译器就会知道i是一个常量，不允许修改； 
3）可以避免意义模糊的数字出现，同样可以很方便地进行参数的调整和修改。 同宏定义一样，可以做到不变   则已，一变都变！
　 如1）中，如果想修改Max的内容，只需要：const int Max=you want;即可！ 
4）可以保护被修饰的东西，防止意外的修改，增强程序的健壮性。 还是上面的例子，如果在函数体内修改了i，编译器就会报错； 
   例如： void f(const int i) { i=10;//error! } 
5）可以节省空间，避免不必要的内存分配。 例如： 
　　#define PI 3.14159 //常量宏 
　　const double Pi=3.14159; //此时并未将Pi放入RAM中 ...... 
　　double i=Pi; //此时为Pi分配内存，以后不再分配！ 
　　double I=PI; //编译期间进行宏替换，分配内存 
　　double j=Pi; //没有内存分配 
　　double J=PI; //再进行宏替换，又一次分配内存！ 
　　const定义常量从汇编的角度来看，只是给出了对应的内存地址，而不是像#define一样给出的是立即数，
    所以，const定义的常量在程序运行过程中只有一份拷贝，而#define定义的常量在内存中有若干份拷贝。 
6） 提高了效率。 
　　编译器通常不为普通const常量分配存储空间，而是将它们保存在符号表中，这使得它成为一个编译期间的常量，
    没有了存储与读内存的操作，使得它的效率也很高。

问题1:const变量&常量
例：为什么下面的例子在使用一个const变量来初始化数组，ANSI C的编译器会报告一个错误呢？
    const int n = 5;
    int a[n];
答案与分析：
1）这个问题讨论的是“常量”与“只读变量”的区别。常量，例如5， "abc"，等，肯定是只读的，因为常量是被编译器放在内存中的只读区域，当然也就不能够去修改它。而“只读变量”则是在内存中开辟一个地方来存放它的值，只不过这个值由编译器限定不允许被修改。C语言关键字const就是用来限定一个变量不允许被改变的修饰符（Qualifier）。上述代码中变量n被修饰为只读变量，可惜再怎么修饰也不是常量。而ANSI C规定数组定义时长度必须是“常量”，“只读变量”也是不可以的，“常量”不等于“不可变的变量”。但是在C++中，局部数组是可以使用变量作为其长度的。
2）但是在标准C++中，这样定义的是一个常量，这种写法是对的。实际上，根据编译过程及内存分配来看，这种用法本来就应该是合理的，只是ANSI C对数组的规定限制了它（实际上用GCC或VS2005编译以上代码，确实没有错误产生，也没有给出警告）。
3）那么，在ANSI C中用什么来定义常量呢？答案是enum类型和#define宏，这两个都可以用来定义常量。

问题2:const怎样限定内容
例：下面的代码编译器会报一个错误，请问，哪一个语句是错误的呢？
    typedef char * pStr;
    char string[4] = "bbc";
    const char *p1 =" string"; //1式
    const pStr p2 =" string"; //2式
    p1++;
    p2++;
答案与分析：
问题出在p2++上。
1）const使用的基本形式： const type m;限定m不可变。替换基本形式中的m为1式中的*p1，替换后const char *p1;限定*p1不可变，当然p1是可变的，因此问题中p1++是对的。替换基本形式中的type为2式中的pStr，替换后const pStr m;限定m不可变，题中的pStr就是一种新类型，因此问题中p2不可[1] 变，p2++是错误的。




先从一级指针说起吧：
（1）const char p    限定变量p为只读。这样如p=2这样的赋值操作就是错误的。
（2）const char *p   p为一个指向char类型的指针，const只限定p指向的对象为只读。这样，p=&a或  p++等操作都是合法的，但如*p=4这样的操作就错了，因为企图改写这个已经被限定为只读属性的对象。
（3）char *const p  限定此指针为只读，这样p=&a或  p++等操作都是不合法的。而*p=3这样的操作合法，因为并没有限定其最终对象为只读。
（4）const char *const p 两者皆限定为只读，不能改写。
有了以上的对比，再来看二级指针问题：
（1）const char **p  p为一个指向指针的指针，const限定其最终对象为只读，显然这最终对象也是为char类型的变量。故像**p=3这样的赋值是错误的，而像*p=？ p++这样的操作合法。
（2）const char * const *p 限定最终对象和 p指向的指针为只读。这样 *p=?的操作也是错的。
（3）const char * const * const p 全部限定为只读，都不可以改写。