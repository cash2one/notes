http://www.trueeyu.com/?p=855
-------------------------------------------------------------------------------------|
强符号:                                                                              |
多个目标文件中含有相同名字的全局符号的定义时，这些目标文件链接时将会出现符号重复定义 |
的错误。这种符号为强符号. 编译器默认函数和初始化了的全局变量为强符号.                |
                                                                                     |
弱符号:                                                                              |
未初始化的全局变量为弱符号. 可以通过GCC的"__attribute__((weak))"来定义任何一个强符号 |
为弱符号.                                                                            |
                                                                                     |
强引用:                                                                              |
链接时如果没有找到这个符号的定义，则报未定义错误                                     |
GCC声明对一个外部函数的引用为弱引用:                                                 |
__attribute__ ((weakref)) void foo()                                                 |
                                                                                     |
弱引用:                                                                              |
链接器不报错，默认其为0或者是一个特殊的值.                                           |
                                                                                     |
规则:                                                                                |
1) 不允许强符号被多次定义, 如果出现, 会报重复定义错误                                |
2) 如果一个符号在某个文件中是强符号, 在其它文件中是弱符号, 那么选择强符号            |
3) 如果一个符号在所有目标文件中都是强符号, 那么选择其中占用空间最大的一个.           |
                                                                                     |
弱引用的用途:                                                                        |
1)库中定义的弱符号可以被用户定义的强符号所覆盖,从而使程序可以使用自定义版本的库函数. |
2)程序可以对某些扩展功能模块的引用定义为弱引用, 当我们将扩展模块和程序链接在一起时,  |
功能模块就可以正常使用, 如果我们去掉了某些功能模块, 那么程序也可以正常链接, 只是缺少 |
了相应的功能, 这使得程序的功能更加容易裁剪和组合.                                    |

实例1：
extern int ext;

int weak;
int strong = 1;
__attribute__((weak)) weak2 = 2;

int main()
{
    return 0;
}                                                                                    |
weak和weak2是弱符号，strong和main是强符号，而"ext"既非强符号也非弱符号, 是一个外部变 |
量的引用.                                                                            |
                                                                                     |
实例:                                                                                |
在linux程序设计中, 如果一个程序被设计成可以支持单线程或多线程的模式, 就可以通过弱引用|
的方法来判断当前的程序是链接到了单线程的Glibc库还是多线程的Glibc库(是否在编译时有    |
-lpthread选项), 从而执行单线程版本的程序或多线程版本的程序. 我们可以在程序中定义一个 |
pthread_create函数的弱引用, 然后程序在运行时动态判断是否链接到pthread库, 从而决定执行|
多线程版本还是单线程版本:                                                            |
int pthread_create
(pthread_t *,const pthread_attr_t*,void* (*)(void*),void*) __attribute__((weak));

int main()
{
    if (pthread_create){
        //multi-thread
    }else{
        //single-thread
    }
}