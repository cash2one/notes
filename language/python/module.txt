#******************************************************************************# 
#-->-->-->-->-->-->-->-->-->            1 模块             <--<--<--<--<--<--<-#
#******************************************************************************#
#模块最大的好处是大大提高了代码的可维护性。其次，编写代码不必从零开始。当一个模
#块编写完毕，就可以被其他地方引用。我们在编写程序的时候，也经常引用其他模块，包
#括Python内置的模块和来自第三方的模块。

#使用模块还可以避免函数名和变量名冲突。相同名字的函数和变量完全可以分别存在不同
#的模块中，因此，我们自己在编写模块时，不必考虑名字会与其他模块冲突。但是也要注
#意，尽量不要与内置函数名字冲突。点这里查看Python的所有内置函数。

#你也许还想到，如果不同的人编写的模块名相同怎么办？为了避免模块名冲突，Python又
#引入了按目录来组织模块的方法，称为包（Package）。

#举个例子，一个abc.py的文件就是一个名字叫abc的模块，一个xyz.py的文件就是一个名字
#叫xyz的模块。

#现在，假设我们的abc和xyz这两个模块名字与其他模块冲突了，于是我们可以通过包来组
#织模块，避免冲突。方法是选择一个顶层包名，比如mycompany，按照如下目录存放：
#|mycompany
#|  __init__.py
#|  abc.py
#|  xyz.py
#引入了包以后，只要顶层的包名不与别人冲突，那所有模块都不会与别人冲突。现在，
#abc.py模块的名字就变成了mycompany.abc，类似的，xyz.py的模块名变成了
#mycompany.xyz。

#请注意，每一个包目录下面都会有一个__init__.py的文件，这个文件是必须存在的，否
#则，Python就把这个目录当成普通目录，而不是一个包。__init__.py可以是空文件，也
#可以有Python代码，因为__init__.py本身就是一个模块，而它的模块名就是mycompany。

#类似的，可以有多级目录，组成多级层次的包结构。比如如下的目录结构：
#|mycompany-web
#|  |web
#|  |  |__init__.py
#|  |  |utils.py
#|  |  |www.py
#|  |__init__.py  
#|  |abc.py
#|  |utils.py
#|  |xyz.py
#文件www.py的模块名就是mycompany.web.www，两个文件utils.py的模块名分别是
#mycompany.utils和mycompany.web.utils。
#mycompany.web也是一个模块，请指出该模块对应的.py文件。
#******************************************************************************# 
#-->-->-->-->-->-->-->-->-->          2 使用模块           <--<--<--<--<--<--<-#
#******************************************************************************#
#Python本身就内置了很多非常有用的模块，只要安装完毕，这些模块就可以立刻使用。

#我们以内建的sys模块为例，编写一个hello的模块：
#!/usr/bin/env python
# -*- coding: utf-8 -*-

' a test module '

__author__ = 'Michael Liao'

import sys

def test():
    args = sys.argv
    if len(args)==1:
        print 'Hello, world!'
    elif len(args)==2:
        print 'Hello, %s!' % args[1]
    else:
        print 'Too many arguments!'

if __name__=='__main__':
    test()
#第1行和第2行是标准注释，第1行注释可以让这个hello.py文件直接在Unix/Linux/Mac上运
#行，第2行注释表示.py文件本身使用标准UTF-8编码；
#第4行是一个字符串，表示模块的文档注释，任何模块代码的第一个字符串都被视为模块的
#文档注释；
#第6行使用__author__变量把作者写进去，这样当你公开源代码后别人就可以瞻仰你的大
#名；

#以上就是Python模块的标准文件模板，当然也可以全部删掉不写，但是，按标准办事肯定
#没错。

#后面开始就是真正的代码部分。
import sys
#导入sys模块后，我们就有了变量sys指向该模块，利用sys这个变量，就可以访问sys模块
#的所有功能。
#sys模块有一个argv变量，用list存储了命令行的所有参数。argv至少有一个元素，因为
#第一个参数永远是该.py文件的名称，例如：
#运行python hello.py获得的sys.argv就是['hello.py']；

#运行python hello.py Michael获得的sys.argv就是['hello.py', 'Michael]。

#最后，注意到这两行代码：

if __name__=='__main__':
    test()
#当我们在命令行运行hello模块文件时，Python解释器把一个特殊变量__name__置为
#__main__，而如果在其他地方导入该hello模块时，if判断将失败，因此，这种if测试可
#以让一个模块通过命令行运行时执行一些额外的代码，最常见的就是运行测试。
#我们可以用命令行运行hello.py看看效果：
$ python hello.py
Hello, world!
$ python hello.py Michael
Hello, Michael!
#如果启动Python交互环境，再导入hello模块：
$ python
Python 2.7.5 (default, Aug 25 2013, 00:04:04) 
[GCC 4.2.1 Compatible Apple LLVM 5.0 (clang-500.0.68)] on darwin
Type "help", "copyright", "credits" or "license" for more information.
>>> import hello
>>>
#导入时，没有打印Hello, word!，因为没有执行test()函数。
#调用hello.test()时，才能打印出Hello, word!：
>>> hello.test()
Hello, world!

#******************************************************************************# 
#-->-->-->-->-->-->-->-->-->            3 别名             <--<--<--<--<--<--<-#
#******************************************************************************#
#导入模块时，还可以使用别名，这样，可以在运行时根据当前环境选择最合适的模块。比
#如Python标准库一般会提供StringIO和cStringIO两个库，这两个库的接口和功能是一样的
#，但是cStringIO是C写的，速度更快，所以，你会经常看到这样的写法：
try:
    import cStringIO as StringIO
except ImportError: # 导入失败会捕获到ImportError
    import StringIO
#这样就可以优先导入cStringIO。如果有些平台不提供cStringIO，还可以降级使用
#StringIO。导入cStringIO时，用import ... as ...指定了别名StringIO，因此，后续代
#码引用StringIO即可正常工作。

#还有类似simplejson这样的库，在Python 2.6之前是独立的第三方库，从2.6开始内置，所
#以，会有这样的写法：
try:
    import json # python >= 2.6
except ImportError:
    import simplejson as json # python <= 2.5
#由于Python是动态语言，函数签名一致接口就一样，因此，无论导入哪个模块后续代码都
#能正常工作。
#******************************************************************************# 
#-->-->-->-->-->-->-->-->-->           3 作用域            <--<--<--<--<--<--<-#
#******************************************************************************#
#在一个模块中，我们可能会定义很多函数和变量，但有的函数和变量我们希望给别人使用，
#有的函数和变量我们希望仅仅在模块内部使用。在Python中，是通过_前缀来实现的。

#正常的函数和变量名是公开的（public），可以被直接引用，比如：abc，x123，PI等；
#类似__xxx__这样的变量是特殊变量，可以被直接引用，但是有特殊用途，比如上面的
#__author__，__name__就是特殊变量，hello模块定义的文档注释也可以用特殊变量
#__doc__访问，我们自己的变量一般不要用这种变量名；

#类似_xxx和__xxx这样的函数或变量就是非公开的（private），不应该被直接引用，比如
#_abc，__abc等；

#之所以我们说，private函数和变量“不应该”被直接引用，而不是“不能”被直接引用，是
#因为Python并没有一种方法可以完全限制访问private函数或变量，但是，从编程习惯上
#不应该引用private函数或变量。

#private函数或变量不应该被别人引用，那它们有什么用呢？请看例子：

def _private_1(name):
    return 'Hello, %s' % name

def _private_2(name):
    return 'Hi, %s' % name

def greeting(name):
    if len(name) > 3:
        return _private_1(name)
    else:
        return _private_2(name)

#我们在模块里公开greeting()函数，而把内部逻辑用private函数隐藏起来了，这样，调
#用greeting()函数不用关心内部的private函数细节，这也是一种非常有用的代码封装和
#抽象的方法，即：
#外部不需要引用的函数全部定义成private，只有外部需要引用的函数才定义为public。

#******************************************************************************# 
#-->-->-->-->-->-->-->-->-->       3 使用__future__        <--<--<--<--<--<--<-#
#******************************************************************************#
#Python的每个新版本都会增加一些新的功能，或者对原来的功能作一些改动。有些改动是
#不兼容旧版本的，也就是在当前版本运行正常的代码，到下一个版本运行就可能不正常了。

#从Python 2.7到Python 3.x就有不兼容的一些改动，比如2.x里的字符串用'xxx'表示str，
#Unicode字符串用u'xxx'表示unicode，而在3.x中，所有字符串都被视为unicode，因此，
#写u'xxx'和'xxx'是完全一致的，而在2.x中以'xxx'表示的str就必须写成b'xxx'，以此表
#示“二进制字符串”。

#要直接把代码升级到3.x是比较冒进的，因为有大量的改动需要测试。相反，可以在2.7版
#本中先在一部分代码中测试一些3.x的特性，如果没有问题，再移植到3.x不迟。

#Python提供了__future__模块，把下一个新版本的特性导入到当前版本，于是我们就可以
#在当前版本中测试一些新版本的特性。举例说明如下：

#为了适应Python 3.x的新的字符串的表示方法，在2.7版本的代码中，可以通过
#unicode_literals来使用Python 3.x的新的语法：

# still running on Python 2.7

from __future__ import unicode_literals

print '\'xxx\' is unicode?', isinstance('xxx', unicode)
print 'u\'xxx\' is unicode?', isinstance(u'xxx', unicode)
print '\'xxx\' is str?', isinstance('xxx', str)
print 'b\'xxx\' is str?', isinstance(b'xxx', str)
#注意到上面的代码仍然在Python 2.7下运行，但结果显示去掉前缀u的'a string'仍是一个
#unicode，而加上前缀b的b'a string'才变成了str：

$ python task.py
'xxx' is unicode? True
u'xxx' is unicode? True
'xxx' is str? False
b'xxx' is str? True
#类似的情况还有除法运算。在Python 2.x中，对于除法有两种情况，如果是整数相除，结
#果仍是整数，余数会被扔掉，这种除法叫“地板除”：
>>> 10 / 3
3
#要做精确除法，必须把其中一个数变成浮点数：

>>> 10.0 / 3
3.3333333333333335
#而在Python 3.x中，所有的除法都是精确除法，地板除用//表示：
$ python3
Python 3.3.2 (default, Jan 22 2014, 09:54:40) 
[GCC 4.2.1 Compatible Apple LLVM 5.0 (clang-500.2.79)] on darwin
Type "help", "copyright", "credits" or "license" for more information.
>>> 10 / 3
3.3333333333333335
>>> 10 // 3
3
#如果你想在Python 2.7的代码中直接使用Python 3.x的除法，可以通过__future__模块的
#division实现：
from __future__ import division
print '10 / 3 =', 10 / 3
print '10.0 / 3 =', 10.0 / 3
print '10 // 3 =', 10 // 3
#结果如下：
10 / 3 = 3.33333333333
10.0 / 3 = 3.33333333333
10 // 3 = 3
#由于Python是由社区推动的开源并且免费的开发语言，不受商业公司控制，因此，Python的
#改进往往比较激进，不兼容的情况时有发生。Python为了确保你能顺利过渡到新版本，特
#别提供了__future__模块，让你在旧的版本中试验新版本的一些特性。
