/*
 希尔排序，也称递减增量排序算法，是插入排序的一种更高效的改进版本。希尔排序是非稳定排序算法。 
 希尔排序是基于插入排序的以下两点性质而提出改进方法的：
 插入排序在对几乎已经排好序的数据操作时， 效率高， 即可以达到线性排序的效率
 但插入排序一般来说是低效的， 因为插入排序每次只能将数据移动一位

 希尔排序通过将比较的全部元素分为几个区域来提升插入排序的性能。这样可以让一个元素可以一次性地朝最终位置前进一大步。
 然后算法再取越来越小的步长进行排序，算法的最后一步就是普通的插入排序，但是到了这步，需排序的数据几乎是已排好的了（此时插入排序较快）。

 步长的选择是希尔排序的重要部分。只要最终步长为1任何步长串行都可以工作。算法最开始以一定的步长进行排序。
 然后会继续以一定步长进行排序，最终算法以步长为1进行排序。当步长为1时，算法变为插入排序，这就保证了数据一定会被排序。



 准备待排数组[6 2 4 1 5 9] 
 首先需要选取关键字,例如关键是3和1(第一步分成三组,第二步分成一组),
 那么待排数组分成了以下三个虚拟组: [6 1]一组 [2 5]二组 [4 9]三组 看仔细啊,不是临近的两个数字分组,而是3(分成了三组)的倍数的数字分成了一组,
 就是每隔3个数取一个,每隔三个再取一个,这样取出来的数字放到一组, 把它们当成一组,但不实际分组,只是当成一组来看,所以上边的"组"实际上并不存在,
 只是为了说明分组关系  对以上三组分别进行插入排序变成下边这样 [1 6] [2 5] [4 9] 
 具体过程:[6 1]6和1交换变成[1 6] 
          [2 5]2与5不动还是[2 5]
          [4 9]4与9不动还是[4 9]
 第一趟排序状态演示:
     待排数组:[6 2 4 1 5 9] 
     排后数组:[1 2 4 6 5 9]

 第二趟关键字取的是1,即每隔一个取一个组成新数组,实际上就是只有一组啦,隔一取一就全部取出来了嘛?此时待排数组为:[1?2?4?6?5?9]?直接对它进行插入排序.

 */

void sort_shell(int array[],int nums)
{
	int i, j, key; 
	int gap = 0;
	
    gap = nums/2;
	
	while (gap > 0) 
	{
	    for(i = gap; i < nums; i++)
	    {
	        key = array[i];
			j = i - gap;

			while((j >= 0) && (array[j] > key))
			{
			    array[j+gap] = array[j];
				j -= gap;
			}

			array[j+gap] = key;
	    }
		
		gap = gap/2;
	}	    
}




#if 0   
#include <stdio.h>
	
int main()
{
	const int n = 5;
	int i, j, temp; 
	int gap = 0;
	int a[] = {5, 4, 3, 2, 1}; 
	while (gap<=n)
	{
		 gap = gap * 3 + 1;
	} 
	while (gap > 0) 
	{
		for ( i = gap; i < n; i++ )
		{
			j = i - gap;
			temp = a[i];			 
			while (( j >= 0 ) && ( a[j] > temp ))
			{
				a[j + gap] = a[j];
				j = j - gap;
			}
			a[j+gap] = temp;
		}
		gap = ( gap - 1 ) / 3;
	}	 
}
#endif

