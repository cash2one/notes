/********************************************************************
                  二叉查找树 binary search tree
********************************************************************
 1 左子树的关键字 <= 父节点的关键字，右子树的关键字 >= 父节点的关键字
 2 中序遍历(先左后右)按key从小到大输出
 3 规定每个节点都是它自己的祖先 
 ********************************************************************/

#ifndef __BST_H__
#define __BST_H__

#define BST_NAMELEN 32 /*包括最后的\0*/

/*二叉查找树节点结构*/
typedef struct _bstnode
{
	struct _bstnode *bst_parent; /*父节点*/
	struct _bstnode *bst_left;   /*左孩子*/
	struct _bstnode *bst_right;  /*右孩子*/
	int              bst_key;    /*节点key值*/
	int              bst_depth;  /*节点高度，根节点是0*/
	int              bst_index;  /*节点在本层的索引 第一个是0 第二个是1*/
}bstnode;

/*树的中序遍历(递归实现):按key的从小到大输出*/
void bst_inorder(bstnode *root);


/*
@root_node:树的根节点
@key      :待插入的关键字  
return    :插入@key后,树的根节点(除了首次插入,根节点无变化)*/
extern bstnode *bst_insert(bstnode *root_node,int key);

/*********************************************************************************************************
  node无子女    : 直接删除。把node父节点的孩子节点置NULL(儿子忘,儿无后,父也无后).
  node有一个子女: 直接删除，把node父节点的孩子置为node节点的孩子(儿子忘,孙子作为儿子,左右位置不变).
  node有两个子女: 删除node的后继(肯定没有左子女)，然后把node的key值置为其后继的key值.
                  即此时node节点位置不变,删除后继后,把node节点的key值修改一下就可以了.
                  比如中序遍历是: 3 6 9,删除6(6的孩子是3 9),那么只要把6的后继9替代6就可以了,中序遍历顺序不变

  1 根据pnode找到真正要删除的节点pdel,可能就是pnode，也可能使pnode的后继
  2 pchild_del置为pdel的非空子节点，找不到则置空
  3 pchild_del非空,且无父节点，说明pchild_del是根节点，好办让pchild_del的娃当根节点。
  4 删除pdel，首先判断pdel是其父亲的左孩子还是右孩子，是左孩子就把自己的孩子pchild_del置为自己父亲的左孩子。
  5 最后如果发现pdel不是入参pnode，说明pnode有两个孩子，把pnode的key值置为其后继的key值
  **********************************************************************************************************
   功能  : 把节点@pnode从树中删除，树的根节点是@proot
   返回值: 树的根节点(可能变化)
  **********************************************************************************************************/
extern bstnode *bst_delete(bstnode *proot,bstnode *pnode);


/*销毁树@root_node,释放节点*/
extern void bst_destory(bstnode *root_node);


/*以节点@pnode为根的树的最小节点,也就是最左的节点*/
extern bstnode *tree_min (bstnode *pnode);

/*以节点@pnode为根的树的最大节点,也就是最右的节点*/
extern bstnode *tree_max (bstnode *pnode);


/***********************************************************************************
  中序遍历的后继节点:按中序遍历输出，在其后输出的那个节点。
  1 p右子树非空,后继为其右子树的最左节点即key值最小那个
    (因为中序遍历是先左后右,既然右子树非空,后继肯定在其中).
  2 p右子树为空，则寻找其父节点。如果p是其父节点的右孩子，那么其父节点已经输出过了。
    以父节点为当前节点继续寻父，直到找到一个节点，这个节点是其父节点的左孩子。
    可能最终也没有找到这样的节点，那么p就是树中最后一个输出节点，没有后继
************************************************************************************
  功能  :返回@pnode节点的后继节点
  返回值:后继节点,没有后继返回NULL
************************************************************************************/
extern bstnode *tree_successor (bstnode *pnode);


/****************************************************************************
  找节点node的前驱
  中序前驱:按中序遍历输出，在节点node前输出的那个节点。 
  左孩子不为空:前驱是node左子树的最大节点
  左孩子为空  :前驱是node祖先，且这个祖先的右孩子也是node的祖先
               找node父节点，如果这个父节点是通过左孩子找到的，则继续向上寻找
*****************************************************************************
功能  :返回@pnode节点的前驱节点
返回值:前驱节点,没有后继返回NULL
****************************************************************************/
extern bstnode *tree_predecessor(bstnode *pnode);


#endif

